"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFetchAsStream = exports.getRequestConfig = exports._patch = exports._post = exports._delete = exports._get = exports.getUrl = exports.normalizePath = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const form_data_1 = __importDefault(require("form-data"));
const debug_1 = __importDefault(require("debug"));
const log = debug_1.default("triply:triplydb-js:http");
function normalizePath(path = "") {
    return `/${path}`.replace(new RegExp("//", "g"), "/");
}
exports.normalizePath = normalizePath;
function getUrl(opts) {
    var _a;
    let url;
    if (opts.url) {
        url = new URL(opts.url);
    }
    else {
        if ((_a = opts.path) === null || _a === void 0 ? void 0 : _a.startsWith("http")) {
            throw new Error(`Expected a path, but got URL ${opts.path} instead`);
        }
        const apiUrl = opts.app["_config"].url;
        if (!apiUrl)
            throw new Error("Expected a url or path to be set");
        url = new URL(apiUrl + normalizePath(opts === null || opts === void 0 ? void 0 : opts.path));
    }
    if (opts.query) {
        url.search = new URLSearchParams(opts.query).toString();
    }
    return url.toString();
}
exports.getUrl = getUrl;
function _get(opts) {
    return handleFetchAsPromise("GET", opts);
}
exports._get = _get;
function _delete(opts) {
    return handleFetchAsPromise("DELETE", opts);
}
exports._delete = _delete;
function _post(opts) {
    return handleFetchAsPromise("POST", opts);
}
exports._post = _post;
function _patch(opts) {
    return handleFetchAsPromise("PATCH", opts);
}
exports._patch = _patch;
function getRequestConfig(method, config) {
    const token = config.app["_config"].token;
    const headers = { "X-Triply-Client": "triplydb-js" };
    if (token) {
        headers["Authorization"] = "Bearer " + token;
    }
    const reqConfig = { method };
    if (config.data) {
        headers["Content-Type"] = "application/json";
        reqConfig.body = JSON.stringify(config.data);
    }
    else if (config.attach) {
        const data = new form_data_1.default();
        for (const [name, body] of Object.entries(config.attach)) {
            if (typeof body === "string") {
                data.append(name, require("fs").createReadStream(body));
            }
            else {
                data.append(name, body);
            }
        }
        reqConfig.body = data;
    }
    reqConfig.headers = headers;
    return reqConfig;
}
exports.getRequestConfig = getRequestConfig;
async function handleFetchAsPromise(method, opts) {
    const url = getUrl(opts);
    log(`_${method.toLowerCase()}`, url);
    const reqOpts = getRequestConfig(method, opts);
    const context = { method, url };
    const errorContext = { errorToThrow: opts.errorWithCleanerStack, context: { method, url } };
    let response;
    try {
        response = await cross_fetch_1.default(url, reqOpts);
    }
    catch (e) {
        throw opts.errorWithCleanerStack.addContext(context).setCause(e);
    }
    errorContext.errorToThrow.statusCode = response.status;
    const consoleOnlyHeader = response.headers.get("x-triply-api");
    if (consoleOnlyHeader) {
        throw opts.errorWithCleanerStack
            .addContext(context)
            .setCause(new Error(`You tried connecting TriplyDB-js to a TriplyDB front-end. Please use the URL of the API instead: ${consoleOnlyHeader}`));
    }
    const expectJsonResponse = !opts.expectedResponseBody || opts.expectedResponseBody === "json";
    const responseContentType = response.headers.get("Content-Type");
    const hasJsonResponse = responseContentType && responseContentType.indexOf("application/json") === 0;
    if (expectJsonResponse && !hasJsonResponse) {
        throw opts.errorWithCleanerStack
            .addContext(context)
            .setCause(new Error(`Expected a JSON response, but got ${responseContentType}.`));
    }
    let result;
    if (hasJsonResponse) {
        try {
            result = await response.json();
        }
        catch (e) {
            throw opts.errorWithCleanerStack.addContext(context).setCause(e);
        }
    }
    else if (opts.expectedResponseBody === "buffer") {
        result = await response.buffer();
    }
    if (response.status >= 400) {
        throw opts.errorWithCleanerStack
            .addContext(context)
            .setCause(response, result instanceof Buffer ? undefined : result);
    }
    return result;
}
async function handleFetchAsStream(method, opts) {
    const url = getUrl(opts);
    log(`_${method.toLowerCase()}`, url);
    const reqOpts = getRequestConfig(method, opts);
    const errorContext = { method, url };
    let response;
    try {
        response = await cross_fetch_1.default(url, reqOpts);
    }
    catch (e) {
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(e);
    }
    const consoleOnlyHeader = response.headers.get("x-triply-api");
    if (consoleOnlyHeader) {
        throw opts.errorWithCleanerStack
            .addContext(errorContext)
            .setCause(new Error(`You tried connecting TriplyDB-js to a TriplyDB front-end. Please use the URL of the API instead: ${consoleOnlyHeader}`));
    }
    const responseContentType = response.headers.get("Content-Type");
    const hasJsonResponse = responseContentType && responseContentType.indexOf("application/json") === 0;
    let jsonResult;
    if (hasJsonResponse) {
        try {
            jsonResult = await response.json();
        }
        catch (e) {
            throw opts.errorWithCleanerStack.addContext(errorContext).setCause(e);
        }
    }
    if (response.status >= 400) {
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(response, jsonResult);
    }
    if (!response.body) {
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(new Error(`Unexpected empty response.`));
    }
    return response.body;
}
exports.handleFetchAsStream = handleFetchAsStream;
//# sourceMappingURL=RequestHandler.js.map