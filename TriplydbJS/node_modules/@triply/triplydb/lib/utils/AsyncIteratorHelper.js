"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parse_link_header_1 = __importDefault(require("parse-link-header"));
const RequestHandler_1 = require("../RequestHandler");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
if (!Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
}
class AsyncIteratorHelper {
    constructor(conf) {
        this._currentPage = [];
        this._config = conf;
    }
    async _getNextPage() {
        if (this._next === null)
            return;
        const reqConfig = RequestHandler_1.getRequestConfig("GET", { app: this._config.app, errorWithCleanerStack: this._config.error });
        const url = this._next || (await this._config.getUrl());
        try {
            const resp = await cross_fetch_1.default(url, reqConfig);
            this._config.error.statusCode = resp.status;
            const pageString = await resp.text();
            if (resp.status >= 400) {
                const contentType = resp.headers.get("content-type");
                let response;
                if (contentType && contentType.indexOf("application/json") === 0) {
                    response = JSON.parse(pageString);
                }
                this._config.error.message = await this._config.getErrorMessage();
                let context = { method: "GET", url };
                if (response)
                    context.response = response;
                throw this._config.error.addContext(context).setCause(resp, response);
            }
            const linkHeaders = parse_link_header_1.default(resp.headers.get("link") || "");
            this._next = (linkHeaders === null || linkHeaders === void 0 ? void 0 : linkHeaders["next"]) && linkHeaders["next"].url ? linkHeaders["next"].url : null;
            const parsePage = this._config.parsePage || JSON.parse;
            this._page = pageString;
            let results;
            try {
                results = await parsePage(pageString);
            }
            catch (e) {
                this._config.error.message = (await this._config.getErrorMessage()) + ": Failed to parse response.";
                this._config.error.addContext({ method: "GET", url }).setCause(resp, results);
                throw this._config.error;
            }
            return results;
        }
        catch (e) {
            this._config.error.message = await this._config.getErrorMessage();
            throw this._config.error.addContext({ method: "GET", url }).setCause(e);
        }
    }
    async _get() {
        if (!this._currentPage.length)
            this._currentPage = (await this._getNextPage()) || [];
        if (this._currentPage.length)
            return this._currentPage.shift();
    }
    async toArray() {
        var e_1, _a;
        const results = [];
        try {
            for (var _b = __asyncValues(this), _c; _c = await _b.next(), !_c.done;) {
                const result = _c.value;
                results.push(result);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return results;
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                const info = await this._get();
                if (info) {
                    return {
                        done: false,
                        value: await this._config.mapResult(info),
                    };
                }
                else {
                    return {
                        done: true,
                    };
                }
            },
        };
    }
}
exports.default = AsyncIteratorHelper;
//# sourceMappingURL=AsyncIteratorHelper.js.map