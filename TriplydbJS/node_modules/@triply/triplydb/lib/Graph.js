"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SUPPORTED_EXTENSIONS = void 0;
const RequestHandler_1 = require("./RequestHandler");
const n3 = __importStar(require("n3"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const zlib = __importStar(require("zlib"));
const pumpify_1 = __importDefault(require("pumpify"));
const path = __importStar(require("path"));
const Error_1 = require("./utils/Error");
exports.SUPPORTED_EXTENSIONS = [".trig", ".nt", ".ttl", ".trig.gz", ".nt.gz", ".ttl.gz"];
class Graph {
    constructor(dataset, info) {
        this._app = dataset["_app"];
        this._info = info;
        this._dataset = dataset;
    }
    async toFile(destinationPath, opts) {
        const parsedPath = path.parse(destinationPath);
        if (exports.SUPPORTED_EXTENSIONS.findIndex((e) => parsedPath.base.endsWith(e)) === -1) {
            throw Error_1.getErr(`Failed so save graph as \`${parsedPath.base}\`. Supported extensions: [ ${exports.SUPPORTED_EXTENSIONS.join(", ")} ]`);
        }
        if (!(await fs_extra_1.default.pathExists(path.resolve(parsedPath.dir)))) {
            throw Error_1.getErr(`Directory doesn't exist: ${parsedPath.dir}`);
        }
        let extension = parsedPath.ext;
        let storeCompressed;
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.compressed) === "boolean") {
            storeCompressed = opts.compressed;
        }
        else {
            storeCompressed = extension === ".gz";
        }
        if (extension === ".gz") {
            extension = `${path.extname(parsedPath.name)}${extension}`;
        }
        const url = await this._getDownloadUrl(extension);
        const res = await cross_fetch_1.default(url, {
            method: "get",
            compress: false,
            headers: { authorization: `bearer ${this._app["_config"].token}` },
        });
        if (res.status >= 400) {
            throw Error_1.getErr(`Failed to download graph ${this._info.graphName}: [#${res.status}] ${res.statusText}`);
        }
        const stream = new pumpify_1.default(res.body, ...(storeCompressed ? [] : [zlib.createGunzip()]), fs_extra_1.default.createWriteStream(destinationPath));
        await new Promise((resolve, reject) => {
            stream.on("error", reject);
            stream.on("finish", resolve);
        });
    }
    async toStore() {
        const store = new n3.Store();
        const stream = await this.toStream("rdf-js");
        await new Promise((resolve, reject) => {
            store.import(stream).on("finish", resolve).on("error", reject);
        });
        return store;
    }
    async toStream(type) {
        const stream = await RequestHandler_1.handleFetchAsStream("GET", {
            app: this._app,
            url: await this._getDownloadUrl(".trig.gz"),
            errorWithCleanerStack: Error_1.getErr(`Failed to download graph ${this._info.graphName}`),
        });
        if (type === "compressed") {
            return stream;
        }
        return new pumpify_1.default.obj(stream, zlib.createGunzip(), new n3.StreamParser());
    }
    async getInfo(refresh = false) {
        if (refresh)
            this._info = await RequestHandler_1._get({
                errorWithCleanerStack: Error_1.getErr(`Failed to get graph information for dataset ${await this._dataset["_getDatasetNameWithOwner"]()}.`),
                app: this._app,
                path: await this._getPath(),
            });
        return this._info;
    }
    async _getDownloadUrl(extension) {
        const dsPath = `${this._app["_config"].url}${await this._dataset["_getDatasetPath"]()}`;
        return `${dsPath}/download${extension || ""}?graph=${encodeURIComponent(this._info.graphName)}`;
    }
    async _getPath() {
        return (await this._dataset["_getDatasetPath"]()) + "/graphs/" + this._info.id;
    }
    async delete() {
        const info = await this.getInfo();
        await RequestHandler_1._delete({
            errorWithCleanerStack: Error_1.getErr(`Failed to graph ${info.graphName} from ${await this._dataset["_getDatasetNameWithOwner"]()}.`),
            app: this._app,
            path: await this._getPath(),
            expectedResponseBody: "empty",
        });
    }
    async rename(newGraphName) {
        if (newGraphName === this._info.graphName)
            return;
        const info = await this.getInfo();
        this._info = await RequestHandler_1._patch({
            errorWithCleanerStack: Error_1.getErr(`Failed to rename graph ${info.graphName} to ${newGraphName} for dataset ${await this._dataset["_getDatasetNameWithOwner"]()}.`),
            app: this._app,
            path: await this._getPath(),
            data: { graphName: newGraphName },
        });
        return this;
    }
}
exports.default = Graph;
//# sourceMappingURL=Graph.js.map