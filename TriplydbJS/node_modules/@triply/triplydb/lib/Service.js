"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const RequestHandler_1 = require("./RequestHandler");
const Error_1 = require("./utils/Error");
class Service {
    constructor(conf) {
        this._app = conf.app;
        this.name = conf.name;
        this.datasetPath = conf.datasetPath;
        this.datasetNameWithOwner = conf.datasetNameWithOwner;
        this.type = conf.type;
        this.reasoner = conf.reasoner;
    }
    async getInfo(refresh = false) {
        if (!refresh && this._info)
            return this._info;
        this._info = await RequestHandler_1._get({
            errorWithCleanerStack: Error_1.getErr(`Failed to get information of service ${this.name} in dataset ${this.datasetNameWithOwner}.`),
            app: this._app,
            path: await this._getServicePath(),
        });
        return this._info;
    }
    async isUpToDate() {
        const info = await this.getInfo(true);
        return !info.outOfSync;
    }
    async delete() {
        this._info = await RequestHandler_1._delete({
            errorWithCleanerStack: Error_1.getErr(`Failed to delete service ${this.name} of dataset ${this.datasetNameWithOwner}.`),
            app: this._app,
            path: await this._getServicePath(),
            expectedResponseBody: "empty",
        });
    }
    async create() {
        await RequestHandler_1._post({
            errorWithCleanerStack: Error_1.getErr(`Failed to create service ${this.name} in dataset ${this.datasetNameWithOwner}.`),
            app: this._app,
            path: `${this.datasetPath}/services`,
            data: {
                name: this.name,
                type: this.type,
                config: this.type === "sparql-jena" && this.reasoner
                    ? {
                        reasonerType: this.reasoner,
                    }
                    : {},
            },
        });
        await this.waitUntilRunning();
        return this;
    }
    async waitUntilRunning() {
        while (true) {
            await utils_1.wait(5000);
            const info = await this.getInfo(true);
            if (info.status === "running") {
                return;
            }
            else if (info.error) {
                throw Error_1.getErr(`Failed to start service ${this.name} of dataset ${this.datasetNameWithOwner}: ${info.error.message}`);
            }
        }
    }
    async update() {
        await RequestHandler_1._post({
            errorWithCleanerStack: Error_1.getErr(`Failed to update service ${this.name} of dataset ${this.datasetNameWithOwner}.`),
            app: this._app,
            path: await this._getServicePath(),
            data: { recreate: true },
        });
        await this.waitUntilRunning();
    }
    async _getServicePath() {
        return `${this.datasetPath}/services/${this.name}`;
    }
}
exports.default = Service;
//# sourceMappingURL=Service.js.map