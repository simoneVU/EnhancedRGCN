"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const App_1 = __importDefault(require("../App"));
const lodash_1 = require("lodash");
const chai = __importStar(require("chai"));
const util_1 = require("util");
const zlib = __importStar(require("zlib"));
const n3_1 = require("n3");
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs = __importStar(require("fs-extra"));
const expect = chai.expect;
process.on("unhandledRejection", function (reason, p) {
    console.warn("Possibly Unhandled Rejection at: Promise ", p, " reason: ", reason);
});
const tmpDir = utils_1.buildPathToSrcPath(__dirname, "tmp");
const datasetsToClean = [];
let testDsIndex = 0;
const getNewTestDs = async (account, accessLevel) => {
    const ds = await account.addDataset({
        name: `${utils_1.CommonUnittestPrefix}-${testDsIndex++}`,
        accessLevel: accessLevel,
    });
    datasetsToClean.push(ds);
    return ds;
};
describe("Dataset", function () {
    let app;
    let user;
    before(async function () {
        await fs.mkdirp(tmpDir);
        app = App_1.default.get({
            url: process.env.UNITTEST_API_URL,
            token: process.env.UNITTEST_TOKEN_ACCOUNT,
        });
        user = await app.getUser();
        await utils_1.resetUnittestAccount(user);
    });
    describe("Adding datasets", function () {
        let testDs;
        before(async function () {
            await utils_1.resetUnittestAccount(user);
            testDs = await getNewTestDs(user, "private");
        });
        it("create dataset", async function () {
            expect(testDs["_info"]).to.exist;
        });
        it("create dataset with invalid name", async function () {
            try {
                await user.addDataset({ name: "____", accessLevel: "private" });
            }
            catch (e) {
                expect(e.message).to.contain("Dataset names can only contain");
                return;
            }
            throw new Error("Expected an err");
        });
    });
    describe("deleting dataset", function () {
        it("deleting an existing dataset", async function () {
            const testDs = await getNewTestDs(user, "private");
            await testDs.delete();
            expect(testDs["_info"]).to.be.undefined;
        });
    });
    describe("Ensuring dataset", function () {
        it("Should create when not already existing", async function () {
            const t = Date.now();
            const ensuredDs = await user.ensureDs(`${utils_1.CommonUnittestPrefix}-ensured`, { license: "PDDL" });
            const dsInfo = await ensuredDs.getInfo();
            expect(new Date(dsInfo.createdAt).getTime()).to.be.greaterThan(t);
            expect(dsInfo.license).to.equal("PDDL");
        });
        it("Should get existing when already existing", async function () {
            const firstDataset = await user.addDataset({ name: `${utils_1.CommonUnittestPrefix}-ensured2` });
            const firstDatasetInfo = await firstDataset.getInfo();
            const ensuredDs = await user.ensureDs(`${utils_1.CommonUnittestPrefix}-ensured2`, { license: "PDDL" });
            const secondDsInfo = await ensuredDs.getInfo();
            expect(firstDatasetInfo.id).to.equal(secondDsInfo.id);
            expect(secondDsInfo.license).to.equal(undefined);
        });
    });
    describe("Change dataset metadata", function () {
        let testDs;
        before(async function () {
            await utils_1.resetUnittestAccount(user);
            testDs = await getNewTestDs(user, "private");
        });
        it("Set avatar", async function () {
            this.timeout(5000);
            let dsInfo = await testDs.getInfo();
            expect(dsInfo.avatarUrl).to.be.undefined;
            await testDs.setAvatar(utils_1.buildPathToSrcPath(__dirname, "__data__", "logo.png"));
            dsInfo = await testDs.getInfo();
            expect(dsInfo.avatarUrl).to.contain("imgs/avatars/d/");
        });
    });
    describe("Manage prefixes", function () {
        let testDs;
        before(async function () {
            testDs = await getNewTestDs(user, "private");
        });
        it("Get all prefixes", async function () {
            const prefixes = await testDs.getPrefixes();
            expect(lodash_1.size(prefixes)).to.be.gt(0);
        });
        it("Remove unknown prefixes", async function () {
            await testDs.removeDatasetPrefixes(["sdg"]);
        });
        it("Add / remove prefixes", async function () {
            const listBefore = await testDs.getPrefixes();
            await testDs.addDatasetPrefixes({ test1: "https://test1", test2: "https://test2" });
            const listAfterAdding = await testDs.getPrefixes();
            expect(lodash_1.size(listAfterAdding) - lodash_1.size(listBefore)).to.equal(2);
            expect(listAfterAdding["test1"]).to.equal("https://test1");
            await testDs.removeDatasetPrefixes(["test1"]);
            const listAfterRemoving = await testDs.getPrefixes();
            expect(lodash_1.size(listAfterRemoving) - lodash_1.size(listBefore)).to.equal(1);
            expect(listAfterRemoving["test1"]).to.be.undefined;
        });
    });
    describe("Import from files", function () {
        let testDs;
        before(async function () {
            await utils_1.resetUnittestAccount(user);
            testDs = await getNewTestDs(user, "private");
        });
        it("Upload", async function () {
            var _a;
            this.timeout(15000);
            await testDs.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
            const info = (_a = testDs["lastJob"]) === null || _a === void 0 ? void 0 : _a.info();
            expect(info === null || info === void 0 ? void 0 : info.files).to.have.lengthOf(2);
        });
        it("Run job", async function () {
            var _a, _b;
            this.timeout(15000);
            expect((_b = (_a = testDs["lastJob"]) === null || _a === void 0 ? void 0 : _a.info()) === null || _b === void 0 ? void 0 : _b.status).to.equal("finished");
        });
    });
    describe("Import from files with overwrite", function () {
        let testDs;
        before(async function () {
            await utils_1.resetUnittestAccount(user);
            testDs = await getNewTestDs(user, "private");
        });
        it.skip("Upload", async function () {
            var _a, _b, _c, _d;
            this.timeout(15000);
            await testDs.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
            let info = (_a = testDs["lastJob"]) === null || _a === void 0 ? void 0 : _a.info();
            expect(info === null || info === void 0 ? void 0 : info.files).to.have.lengthOf(2);
            this.timeout(15000);
            expect((_c = (_b = testDs["lastJob"]) === null || _b === void 0 ? void 0 : _b.info()) === null || _c === void 0 ? void 0 : _c.status).to.equal("finished");
            await testDs.importFromFiles({ overwriteAll: true }, utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
            info = (_d = testDs["lastJob"]) === null || _d === void 0 ? void 0 : _d.info();
            expect(info === null || info === void 0 ? void 0 : info.files).to.have.lengthOf(2);
            expect(await testDs.getGraphs().toArray()).to.have.lengthOf(2);
            const ds2 = user.getDataset((await testDs.getInfo()).name);
            expect(await ds2.getGraphs().toArray()).to.have.lengthOf(2);
            expect((await ds2.getInfo()).graphCount).to.equal(2);
        });
    });
    describe("Import from store", function () {
        let testDs;
        before(async function () {
            this.timeout(10000);
            await utils_1.resetUnittestAccount(user);
            testDs = await getNewTestDs(user, "private");
        });
        it("Import", async function () {
            this.timeout(10000);
            const store = new n3_1.Store();
            const term = n3_1.DataFactory.namedNode("a:a");
            store.addQuad(term, term, term, term);
            await testDs.importFromStore(store);
            const dsInfo = await testDs.getInfo();
            expect(dsInfo.statements).to.equal(1);
        });
    });
    describe("Describing IRI", function () {
        let testDs;
        before(async function () {
            this.timeout(5000);
            testDs = await getNewTestDs(user, "private");
            await testDs.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"));
        });
        it("With empty iri", async function () {
            await expect(testDs.describe("")).eventually.rejectedWith(/Failed to describe '' of/);
        });
        it("With iri that does not exist", async function () {
            const results = await testDs.describe("https://whatever");
            expect(results).to.have.lengthOf(0);
        });
        it("With iri that exists", async function () {
            const results = await testDs.describe("http://data.socialhistory.org/vocab/hisco/entry/");
            expect(results).to.have.lengthOf(8);
        });
    });
    describe("Blocking simultaneous jobs for same dataset", function () {
        it("Should block two simultaneous jobs for the same dataset", async function () {
            this.timeout(10000);
            const ds = await getNewTestDs(user, "private");
            return expect(Promise.all([
                ds.importFromUrls("https://api.triplydb.com/datasets/vocabulary/music-keys/download"),
                ds.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq")),
            ])).to.eventually.rejectedWith("There is already an ongoing job for this dataset. Await that one first.");
        });
        it("Should not block two consequtive jobs for the same dataset", async function () {
            this.timeout(15000);
            const ds = await getNewTestDs(user, "private");
            await ds.importFromUrls("https://api.triplydb.com/datasets/vocabulary/music-keys/download");
            await ds.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
        });
    });
    describe("Clear resources", function () {
        let testDs;
        beforeEach(async function () {
            testDs = await getNewTestDs(user, "private");
        });
        it("Clear graphs", async function () {
            this.timeout(10000);
            await testDs.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "small.nq"));
            expect((await testDs.getInfo(true)).graphCount).to.equal(2);
            await testDs.clear("graphs");
            expect((await testDs.getInfo(true)).graphCount).to.equal(0);
        });
        it("Clear assets", async function () {
            await testDs.uploadAsset(utils_1.buildPathToSrcPath(__dirname, "__data__", "small.nq"), "small.nq");
            expect((await testDs.getInfo(true)).assetCount).to.equal(1);
            await testDs.clear("assets");
            expect((await testDs.getInfo(true)).assetCount).to.equal(0);
        });
        it.skip("Clear services", async function () {
            this.timeout(30000);
            await testDs.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "small.nq"));
            await testDs.addService("sparql", "sparql");
            expect((await testDs.getInfo(true)).serviceCount).to.equal(1);
            await testDs.clear("services");
            expect((await testDs.getInfo(true)).serviceCount).to.equal(0);
        });
        it.skip("Clear all resources", async function () {
            this.timeout(35000);
            await Promise.all([
                testDs
                    .importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "small.nq"))
                    .then(() => testDs.addService("sparql", "sparql")),
                testDs.uploadAsset(utils_1.buildPathToSrcPath(__dirname, "__data__", "small.nq"), "small.nq"),
            ]).then(() => testDs.getInfo(true));
            const preClear = await testDs.getInfo();
            expect(preClear.serviceCount).to.equal(1);
            expect(preClear.assetCount).to.equal(1);
            expect(preClear.graphCount).to.equal(2);
            await testDs.clear("assets", "graphs", "services");
            const postClear = await testDs.getInfo();
            expect(postClear.serviceCount).to.equal(0);
            expect(postClear.assetCount).to.equal(0);
            expect(postClear.graphCount).to.equal(0);
        });
        it("Should throw on wrong key", async function () {
            return expect(testDs.clear("no")).eventually.rejectedWith(`Unrecognized resource type: no`);
        });
    });
    describe("Assets", function () {
        let testDs;
        beforeEach(async function () {
            testDs = await getNewTestDs(user, "private");
        });
        it("add an asset", async function () {
            var e_1, _a;
            this.timeout(5000);
            expect((await testDs.uploadAsset(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), "test102.nt")).getInfo()
                .versions.length).to.equal(1);
            let assetCount = 0;
            try {
                for (var _b = __asyncValues(testDs.getAssets()), _c; _c = await _b.next(), !_c.done;) {
                    let asset = _c.value;
                    asset && assetCount++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            expect(assetCount).to.equal(1);
        });
        it("add and remove an asset", async function () {
            this.timeout(5000);
            const assetsBefore = await testDs.getAssets().toArray();
            const addedAsset = await testDs.uploadAsset(__filename, "test");
            expect(await testDs.getAssets().toArray()).to.have.lengthOf(assetsBefore.length + 1);
            await addedAsset.delete();
            expect(await testDs.getAssets().toArray()).to.have.lengthOf(assetsBefore.length);
        });
        it("download an asset", async function () {
            this.timeout(15000);
            const originalFile = utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt");
            const toLocation = path_1.default.resolve(tmpDir, "test102.nt");
            await testDs.uploadAsset(originalFile, "test102.nt");
            const asset = await testDs.getAsset("test102.nt");
            await asset.toFile(toLocation);
            expect(await fs.pathExists(toLocation)).to.be.true;
            const originalFileContent = await fs.readFile(originalFile, "utf8");
            const downloadedFileContent = await fs.readFile(toLocation, "utf8");
            expect(originalFileContent).to.equal(downloadedFileContent);
        });
        it("stream through an asset", async function () {
            this.timeout(10000);
            const originalFile = utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt");
            await testDs.uploadAsset(originalFile, "test102.nt");
            const asset = await testDs.getAsset("test102.nt");
            let content = Buffer.from("");
            const stream = await asset.toStream();
            await new Promise((resolve, reject) => {
                stream.on("data", (data) => {
                    content += data;
                });
                stream.on("error", reject);
                stream.on("finish", resolve);
            });
            const originalFileContent = (await fs.readFile(originalFile)).toString();
            expect(originalFileContent).to.equal(content.toString());
        });
        it("add asset with used name", async function () {
            this.timeout(5000);
            await testDs.uploadAsset(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), "test102.nt");
            try {
                await testDs.uploadAsset(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), "test102.nt");
            }
            catch (e) {
                return;
            }
            throw new Error("should have thrown");
        });
    });
    describe("With dataset that has graphs", function () {
        let testDs;
        before(async function () {
            this.timeout(10000);
            testDs = await getNewTestDs(user, "private");
            await testDs.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
        });
        describe("Download graphs", function () {
            it("and decompress", async function () {
                await testDs.graphsToFile(path_1.default.resolve(tmpDir, "out.trig"));
            });
            it("keep compression", async function () {
                const outfile = path_1.default.resolve(tmpDir, "out.trig.gz");
                await testDs.graphsToFile(outfile);
                await util_1.promisify(zlib.gunzip)(await fs.readFile(outfile));
            });
        });
        it("Should have graphs", async function () {
            var e_2, _a;
            let graphs = [];
            try {
                for (var _b = __asyncValues(testDs.getGraphs()), _c; _c = await _b.next(), !_c.done;) {
                    let graph = _c.value;
                    graph && graphs.push(graph);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            expect(graphs).to.have.lengthOf(2);
            expect(graphs.find((g) => g["_info"].numberOfStatements === 103)).to.exist;
            expect(graphs.find((g) => g["_info"].numberOfStatements === 1)).to.exist;
        });
        it("download a graph", async function () {
            var e_3, _a;
            this.timeout(10000);
            await fs.mkdirp(utils_1.buildPathToSrcPath(__dirname, "tmp"));
            try {
                for (var _b = __asyncValues(testDs.getGraphs()), _c; _c = await _b.next(), !_c.done;) {
                    let g = _c.value;
                    if (g) {
                        const gzipped = utils_1.buildPathToSrcPath(__dirname, "tmp", "testf.trig.gz");
                        const gunzipped = utils_1.buildPathToSrcPath(__dirname, "tmp", "testf.trig");
                        await g.toFile(utils_1.buildPathToSrcPath(__dirname, "tmp", "testf.trig.gz"));
                        await g.toFile(utils_1.buildPathToSrcPath(__dirname, "tmp", "testf.trig"));
                        expect(await fs.pathExists(gzipped));
                        expect(await fs.pathExists(gunzipped));
                    }
                    break;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
        it("stream through a graph", async function () {
            var e_4, _a;
            this.timeout(10000);
            try {
                for (var _b = __asyncValues(testDs.getGraphs()), _c; _c = await _b.next(), !_c.done;) {
                    let g = _c.value;
                    if (g) {
                        const stream = (await g.toStream("rdf-js"));
                        await new Promise((resolve, reject) => {
                            stream.on("error", (e) => reject(e));
                            stream.on("finish", resolve);
                        });
                    }
                    break;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
        it("Should be able to rename", async function () {
            const newName = utils_1.CommonUnittestPrefix + lodash_1.times(20, () => lodash_1.random(35).toString(36)).join("");
            await testDs.update({ name: newName });
            expect((await testDs.getInfo()).name).to.equal(newName);
        });
        describe("Import from dataset", function () {
            let dsToImportFrom;
            before(async function () {
                var _a, _b;
                this.timeout(10000);
                dsToImportFrom = await getNewTestDs(user, "private");
                await dsToImportFrom.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test102.nt"), utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
                expect((_b = (_a = testDs["lastJob"]) === null || _a === void 0 ? void 0 : _a.info()) === null || _b === void 0 ? void 0 : _b.status).to.equal("finished");
            });
            it("import empty graphs", async function () {
                const importedGraphs = await testDs.importFromDataset({ fromDataset: dsToImportFrom, graphs: {} });
                expect(importedGraphs).to.have.lengthOf(0);
            });
            it("import graph that doesnt exist", async function () {
                try {
                    await testDs.importFromDataset({
                        fromDataset: dsToImportFrom,
                        graphs: { blaaaaaaa: "http://tosomethingelse" },
                    });
                }
                catch (_a) {
                    return;
                }
                throw new Error("Expected an err");
            });
            it("import single graph", async function () {
                var e_5, _a;
                let testDsGraphs = [];
                try {
                    for (var _b = __asyncValues(testDs.getGraphs()), _c; _c = await _b.next(), !_c.done;) {
                        let graph = _c.value;
                        graph && testDsGraphs.push(graph);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                const importedGraphs = await testDs.importFromDataset({
                    fromDataset: dsToImportFrom,
                    graphs: {
                        [testDsGraphs[0]["_info"].graphName]: "http://tosomethingelse",
                    },
                });
                expect(importedGraphs).to.have.lengthOf(1);
            });
            it("import graph with overwrite", async function () {
                var e_6, _a;
                let testDsGraphs = [];
                try {
                    for (var _b = __asyncValues(dsToImportFrom.getGraphs()), _c; _c = await _b.next(), !_c.done;) {
                        let graph = _c.value;
                        graph && testDsGraphs.push(graph);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                const numPreGraphs = (await testDs.getGraphs().toArray()).length;
                await testDs.importFromDataset({
                    fromDataset: dsToImportFrom,
                    graphs: {
                        [testDsGraphs[0]["_info"].graphName]: "http://new-name",
                        [testDsGraphs[1]["_info"].graphName]: "http://new-name-2",
                    },
                    overwrite: false,
                });
                const importedGraphs = await testDs.importFromDataset({
                    fromDataset: dsToImportFrom,
                    graphs: {
                        [testDsGraphs[0]["_info"].graphName]: "http://new-name",
                        [testDsGraphs[1]["_info"].graphName]: "http://new-name-3",
                    },
                    overwrite: true,
                });
                expect(importedGraphs).to.have.lengthOf(1);
                expect(await testDs.getGraphs().toArray()).to.have.length(3 + numPreGraphs);
            });
            it("import all graphs", async function () {
                const sourceDs = dsToImportFrom;
                const targetDs = await getNewTestDs(user, "private");
                const sourceDsGraphCount = (await sourceDs.getGraphs().toArray()).length;
                const targetDsGraphCount = (await targetDs.getGraphs().toArray()).length;
                let importedGraphs = await targetDs.importFromDataset({ fromDataset: sourceDs });
                expect(importedGraphs[0].graphs).to.have.lengthOf(sourceDsGraphCount);
                expect(await targetDs.getGraphs().toArray()).to.have.length(sourceDsGraphCount + targetDsGraphCount);
                importedGraphs = await targetDs.importFromDataset({ fromDataset: sourceDs, overwrite: true });
                expect(importedGraphs[0].graphs).to.have.lengthOf(sourceDsGraphCount);
                expect(await targetDs.getGraphs().toArray()).to.have.length(sourceDsGraphCount + targetDsGraphCount);
            });
        });
        describe.skip("Service tests", function () {
            it("Should make, restart, and delete a service", async function () {
                var e_7, _a, e_8, _b, e_9, _c, e_10, _d;
                var _e;
                this.timeout(60000);
                const dsToImportFrom = await getNewTestDs(user, "private");
                await dsToImportFrom.importFromFiles(utils_1.buildPathToSrcPath(__dirname, "__data__", "test103.nq"));
                await ((_e = dsToImportFrom["lastJob"]) === null || _e === void 0 ? void 0 : _e.exec());
                let testDsGraphs = [];
                try {
                    for (var _f = __asyncValues(testDs.getGraphs()), _g; _g = await _f.next(), !_g.done;) {
                        let graph = _g.value;
                        graph && testDsGraphs.push(graph);
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_a = _f.return)) await _a.call(_f);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                await testDs.importFromDataset({
                    fromDataset: dsToImportFrom,
                    graphs: {
                        [testDsGraphs[0]["_info"].graphName]: "http://tosomethingelse",
                    },
                });
                const service = await testDs.addService("sparql", "testService");
                let serviceList = [];
                try {
                    for (var _h = __asyncValues(testDs.getServices()), _j; _j = await _h.next(), !_j.done;) {
                        let s = _j.value;
                        s && serviceList.push(s);
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_b = _h.return)) await _b.call(_h);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
                expect((await service.getInfo()).id).to.equal((await serviceList[0].getInfo()).id);
                expect(await service.isUpToDate()).to.be.true;
                await testDs.importFromDataset({
                    fromDataset: dsToImportFrom,
                    graphs: {
                        [testDsGraphs[1]["_info"].graphName]: "http://tosomethingelse2",
                    },
                });
                expect(await service.isUpToDate()).to.be.false;
                await service.update();
                expect(await service.isUpToDate()).to.be.true;
                serviceList = [];
                try {
                    for (var _k = __asyncValues(testDs.getServices()), _l; _l = await _k.next(), !_l.done;) {
                        let s = _l.value;
                        s && serviceList.push(s);
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) await _c.call(_k);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
                expect(serviceList).to.have.length(1);
                await service.delete();
                serviceList = [];
                try {
                    for (var _m = __asyncValues(testDs.getServices()), _o; _o = await _m.next(), !_o.done;) {
                        let s = _o.value;
                        s && serviceList.push(s);
                    }
                }
                catch (e_10_1) { e_10 = { error: e_10_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) await _d.call(_m);
                    }
                    finally { if (e_10) throw e_10.error; }
                }
                expect(serviceList).to.have.length(0);
            });
        });
    });
});
//# sourceMappingURL=Dataset-test.js.map