"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const RequestHandler_1 = require("./RequestHandler");
const pumpify_1 = __importDefault(require("pumpify"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const Error_1 = require("./utils/Error");
const lodash_1 = require("lodash");
const tus = require("@triply/tus-js-client");
class Asset {
    constructor(dataset, info, selectedVersion) {
        this._deleted = false;
        this._info = info;
        this._dataset = dataset;
        this._app = dataset["_app"];
        if (selectedVersion !== undefined) {
            this.selectVersion(selectedVersion);
        }
    }
    async _getUrl(versionInfo) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        const urlparts = [
            this._app["_config"].url,
            await this._dataset["_getDatasetPath"](),
            "/assets",
            `/${this._info.identifier}`,
        ];
        if (versionInfo)
            urlparts.push(`/${versionInfo.id}`);
        return urlparts.join("");
    }
    async toFile(destinationPath, versionNumber) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        const url = await this._getUrl(versionNumber === undefined ? this._getLastVersionInfo() : this.getVersionInfo(versionNumber));
        const res = await cross_fetch_1.default(url, { method: "get", headers: { authorization: `bearer ${this._app["_config"].token}` } });
        const stream = new pumpify_1.default(res.body, fs.createWriteStream(destinationPath));
        await new Promise((resolve, reject) => {
            stream.on("error", reject);
            stream.on("finish", resolve);
        });
    }
    async toStream(versionNumber) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        const url = await this._getUrl(versionNumber === undefined ? undefined : this.getVersionInfo(versionNumber));
        const res = await cross_fetch_1.default(url, { method: "get", headers: { authorization: `bearer ${this._app["_config"].token}` } });
        return res.body;
    }
    _getLastVersionInfo() {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        const lastVersion = lodash_1.last(this._info.versions);
        if (!lastVersion)
            throw Error_1.getErr("This asset has no versions");
        return lastVersion;
    }
    getVersionInfo(versionNumber) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        const version = this._info.versions[versionNumber];
        if (!version)
            throw Error_1.getErr(`This asset has no version ${versionNumber}`);
        return version;
    }
    getInfo(versionNumber) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        let versionInfo = versionNumber === undefined ? this._getLastVersionInfo() : this.getVersionInfo(versionNumber);
        return Object.assign(Object.assign({}, this._info), lodash_1.omit(versionInfo, "id"));
    }
    async refreshInfo() {
        this._info = (await RequestHandler_1._get({
            errorWithCleanerStack: Error_1.getErr(`Failed to get refresh info for asset '${this._info.assetName}' from dataset ${await this._dataset["_getDatasetNameWithOwner"]()}.`),
            app: this._app,
            path: await this._dataset["_getDatasetPath"]("/assets"),
            query: { fileName: this._info.assetName },
        }));
        return this;
    }
    selectVersion(versionNumber) {
        if (!this.getInfo().versions[versionNumber])
            throw Error_1.getErr(`Tried to select version ${versionNumber} but asset '${this.getInfo().assetName}' only has ${this.getInfo().versions.length} versions. (version numbering starts at 0) `);
        this._selectedVersion = versionNumber;
        return this;
    }
    async addVersion(fileOrPath) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        await Asset.uploadAsset({ fileOrPath, dataset: this._dataset, versionOf: this._info.identifier });
        await this.refreshInfo();
        return this;
    }
    async delete(versionNumber) {
        if (this._deleted)
            throw Error_1.getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        const dsInfo = await this._dataset.getInfo();
        await RequestHandler_1._delete({
            app: this._app,
            url: await this._getUrl(versionNumber === undefined ? undefined : this.getVersionInfo(versionNumber)),
            errorWithCleanerStack: Error_1.getErr(`Failed to delete asset ${this._info.assetName} in dataset ${dsInfo.owner.accountName}/${dsInfo.name}.`),
            expectedResponseBody: "empty",
        });
        if (versionNumber === undefined || (versionNumber === 0 && this.getInfo().versions.length === 1)) {
            this._deleted = true;
        }
        else {
            if (this._selectedVersion !== undefined) {
                if (this._selectedVersion === versionNumber) {
                    this._selectedVersion = undefined;
                }
                else if (this._selectedVersion > versionNumber) {
                    this._selectedVersion = this._selectedVersion - 1;
                }
            }
            await this.refreshInfo();
            return this;
        }
    }
    static async uploadAsset(opts) {
        let rs;
        let fileSize;
        if (typeof opts.fileOrPath === "string") {
            if (fs.createReadStream === undefined) {
                throw Error_1.getErr('"fs" is not loaded in this environment, use a "File" instead');
            }
            rs = fs.createReadStream(opts.fileOrPath);
            fileSize = (await fs.stat(opts.fileOrPath)).size;
        }
        else {
            rs = opts.fileOrPath;
            fileSize = opts.fileOrPath.size;
        }
        const info = await opts.dataset.getInfo();
        return new Promise((resolve, reject) => {
            const upload = new tus.Upload(rs, {
                endpoint: `${opts.dataset["_app"]["_config"].url}/datasets/${info.owner.accountName}/${info.name}/assets/add`,
                resume: true,
                metadata: { filename: opts.assetName, versionOf: opts.versionOf },
                headers: { Authorization: "Bearer " + opts.dataset["_app"]["_config"].token },
                chunkSize: 5 * 1024 * 1024,
                retryDelays: [2000, 3000, 5000, 10000, 20000],
                uploadSize: fileSize,
                onError: (error) => reject(error),
                onProgress: (_bytesUploaded, _bytesTotal) => { },
                onSuccess: (stringifiedJson) => {
                    if (stringifiedJson === "")
                        return reject(Error_1.getErr("No response or upload already finished"));
                    resolve(JSON.parse(stringifiedJson));
                },
            });
            upload.start();
        });
    }
}
exports.default = Asset;
//# sourceMappingURL=Asset.js.map