/// <reference types="node" />
import { Models } from "@triply/utils";
import App from "./App";
import Service from "./Service";
import * as stream from "stream";
import * as n3 from "n3";
import { Account } from "./Account";
import AsyncIteratorHelper from "./utils/AsyncIteratorHelper";
import Asset from "./Asset";
import Graph from "./Graph";
import { NamedNode } from "rdf-js";
interface JobDefaultsConfig {
    defaultGraphName?: string;
    baseIRI?: string;
    overwriteAll?: boolean;
}
declare type DsResourceType = "assets" | "graphs" | "services";
declare type ImportOpts = {
    fromDataset: Dataset;
    graphs?: {
        [from: string]: string;
    };
    overwrite?: boolean;
};
export default class Dataset {
    private _app;
    private _info?;
    private _owner;
    private lastJob?;
    private _name;
    private allPrefixes;
    constructor(app: App, owner: Account, datasetName: string, datasetInfo?: Models.Dataset);
    getServices(): AsyncIteratorHelper<Models.ServiceMetadata, Service>;
    removeAllGraphs(): Promise<this>;
    clear(resourceType: DsResourceType, ...rest: DsResourceType[]): Promise<this>;
    exists(): Promise<boolean>;
    getGraph(graphNameOrIri: string | NamedNode): Promise<Graph>;
    deleteGraph(graphNameOrIri: string | NamedNode): Promise<void>;
    private _setInfo;
    private _getDatasetPath;
    private _getDatasetNameWithOwner;
    getInfo(refresh?: boolean): Promise<Models.Dataset>;
    getAsset(assetName: string, versionNumber?: number): Promise<Asset>;
    getAssets(): AsyncIteratorHelper<Models.Asset, Asset>;
    getGraphs(): AsyncIteratorHelper<Models.Graph, Graph>;
    private _getDownloadPath;
    graphsToFile(destinationPath: string, opts?: {
        compressed?: boolean;
    }): Promise<void>;
    graphsToStream(type: "compressed" | "rdf-js"): Promise<stream.Readable>;
    graphsToStore(): Promise<n3.Store>;
    importFromDataset(opts: ImportOpts): Promise<Models.Imports>;
    importFromDataset(opts: Dataset, graphs: {
        [from: string]: string;
    }, overwrite?: boolean): Promise<Models.Imports>;
    update(config: Models.UpdateDataset): Promise<this>;
    copy(toAccountName: string, newDatasetName?: string): Promise<Dataset>;
    renameGraph(from: string, to: string): Promise<Graph>;
    delete(): Promise<void>;
    setAvatar(pathBufferOrFile: string | Buffer | File): Promise<this>;
    private _throwIfJobRunning;
    importFromFiles(...files: File[]): Promise<Dataset>;
    importFromFiles(...files: string[]): Promise<Dataset>;
    importFromFiles(defaultsConfig: JobDefaultsConfig, ...files: string[] | File[]): Promise<Dataset>;
    importFromStore(store: n3.Store): Promise<Dataset>;
    importFromStore(opts: JobDefaultsConfig, store: n3.Store): Promise<Dataset>;
    importFromUrls(...urls: string[]): Promise<Dataset>;
    importFromUrls(opts: JobDefaultsConfig, ...urls: string[]): Promise<Dataset>;
    describe(iri: string | NamedNode): Promise<n3.Quad[]>;
    getStatements(payload: {
        subject?: string;
        predicate?: string;
        object?: string;
        graph?: string;
    }): AsyncIteratorHelper<Models.Statement, Models.Statement>;
    uploadAsset(fileOrPath: string | File, assetName?: string): Promise<Asset>;
    addService(type: Models.ServiceType, name: string, reasoner?: Models.JenaReasoners): Promise<Service>;
    addDatasetPrefixes(newPrefixes: {
        [key: string]: string;
    }): Promise<{
        [prefixLabel: string]: string;
    }>;
    removeDatasetPrefixes(prefixLabels: string[]): Promise<{
        [prefixLabel: string]: string;
    }>;
    getPrefixes(refresh?: boolean): Promise<{
        [prefixLabel: string]: string;
    }>;
}
interface JobConfig {
    app: App;
    baseIRI?: string;
    defaultGraphName?: string;
    overwriteAll?: boolean;
    datasetPath: string;
    datasetNameWithOwner: string;
}
export declare class JobUpload {
    private _config;
    private _info?;
    private jobUrl?;
    constructor(conf: JobConfig);
    getJobUrl(): string;
    create(): Promise<this>;
    info(): Models.Job;
    private uploadFile;
    uploadFiles(...files: string[] | File[]): Promise<this>;
    private refresh;
    exec(): Promise<void>;
}
export {};
