import { Statement, Prefix, PrefixInfo } from "./";
import { SERVICE_TYPES, QUERY_TYPES } from "./Constants";
import { MarkRequired } from "ts-essentials";
export { Statement } from "./";
export { Prefix, PrefixInfo } from "./";
export interface ParsingContext {
    line: number;
    lines?: {
        [line: number]: string;
    };
    token?: Token;
    previousToken?: Token;
}
export interface ErrorResponse {
    code?: number;
    message: string;
    errors?: ErrorResponse[];
    serverError?: string;
    files?: string[];
    parsingContext?: ParsingContext;
    failedFileType?: "xml" | "nquads" | "ntriples" | "turtle" | "trig" | "bzip" | "gzip" | "zip" | "rar" | "7z" | "tar" | string;
}
export interface JwtPayloadReserved {
    iss: string;
    jti: string;
    exp: number;
    iat?: number;
}
export interface JwtPayloadCustom {
    imp?: string;
    uid: string;
    aud?: string;
    sub?: string;
}
export interface Scopes {
    acc?: Array<"pub" | "priv" | "a">;
    ds?: Array<"c" | "r" | "u" | "d" | "a">;
    us?: Array<"u" | "a">;
    tok?: Array<"c" | "a">;
    cust?: string[];
}
export interface JwtPayload extends JwtPayloadCustom, JwtPayloadReserved {
}
export declare type OrgRole = "owner" | "member";
export interface OrgMember {
    role: OrgRole;
    user: User;
    createdAt: string;
    updatedAt: string;
}
export interface OrgMemberUpdate {
    role: OrgRole;
}
export declare type AccountType = "user" | "org";
export declare type PinnedItemType = "Dataset" | "Query" | "Story";
export interface PinnedDataset {
    type: "Dataset";
    item: DatasetPublic;
}
export interface PinnedQuery {
    type: "Query";
    item: Query;
}
export interface PinnedStory {
    type: "Story";
    item: Story;
}
export declare type PinnedItem = PinnedDataset | PinnedQuery | PinnedStory;
export interface PinnedItemUpdate {
    type: PinnedItemType;
    item: string;
}
export interface AccountPublic {
    avatarUrl?: string;
    accountName: string;
    name?: string;
    description: string;
    uid: string;
    createdAt: string;
    pinnedItems?: PinnedItem[];
    datasetCount?: number;
    queryCount?: number;
    storyCount?: number;
}
export interface AccountPrivate {
    email?: string;
    updatedAt: string;
}
export interface AccountUpdate {
    name?: string;
    email?: string;
    accountName?: string;
    pinnedItems?: PinnedItemUpdate[];
    description?: string;
}
export declare type Account = User | Org;
export declare type UserRole = "superAdmin" | "siteAdmin" | "regular" | "light" | "none";
export interface UserPublic {
    type: "user";
    role?: UserRole;
    orgs?: Org[];
}
export interface UserPrivate {
    impersonatedBy?: string;
    authMethod: string;
    verified: boolean;
    legalConsent?: boolean;
    disabled: boolean;
    expiresAt?: string;
    role?: UserRole;
    lastActivity?: string;
    usageInfo?: {
        services: string[];
        graphCount: number;
        statementCount: number;
        assetBytes: number;
    };
}
export interface UserUpdate extends AccountUpdate {
    role?: UserRole;
    disabled?: boolean;
    expiresAt?: string;
    verified?: boolean;
    legalConsent?: boolean;
}
export declare type User = Partial<AccountPrivate> & Partial<UserPrivate> & AccountPublic & UserPublic;
export interface BulkUserReport {
    success: number;
    errors: {
        account: string;
        message: string;
    }[];
}
export interface OrgPublic {
    type: "org";
    members?: OrgMember[];
}
export interface OrgPrivate {
}
export interface OrgUpdate extends AccountUpdate {
}
export declare type Org = Partial<AccountPrivate> & Partial<OrgPrivate> & AccountPublic & OrgPublic;
export declare type AccessLevel = "public" | "private" | "internal";
export declare type DatasetLicenses = "PDDL" | "ODC-By" | "ODC-ODbL" | "CC0 1.0" | "CC-BY-SA" | "GFDL" | null;
export declare type Dataset = DatasetPublic;
export interface DatasetPublic {
    id: string;
    name: string;
    description: string;
    displayName: string;
    avatarUrl: string | undefined;
    owner: Account;
    accessLevel: AccessLevel;
    license: DatasetLicenses;
    createdAt: string;
    updatedAt: string;
    graphCount: number;
    statements: number;
    lastGraphsUpdateTime: string;
    serviceCount: number;
    assetCount: number;
    topics: Topic[];
    implicitTopics: Topic[];
    exampleResources: string[];
}
export interface DatasetVerbose extends DatasetPublic {
    services: Service[];
    largestGraphs: Graphs;
    openJobs?: Job[];
}
export interface UpdateDataset {
    displayName?: string;
    description?: string;
    name?: string;
    accessLevel?: AccessLevel;
    license?: DatasetLicenses;
    topics?: string[];
    exampleResources?: string[];
}
export interface NewDataset {
    name?: string;
    displayName?: string;
    toAccount?: string;
    description?: string;
    accessLevel?: AccessLevel;
    license?: DatasetLicenses;
}
export declare type ServiceType = typeof SERVICE_TYPES[number];
export declare type QueryType = typeof QUERY_TYPES[number];
export declare type ServiceStatus = "starting" | "running" | "stopping" | "stopped" | "removing" | "updating" | "error";
export declare type LoadStatus = "loaded" | "loading" | "error" | "notLoaded";
export interface ServiceGraphsInfo {
    [graphName: string]: ServiceGraphInfo;
}
export interface ServiceGraphInfo {
    status: LoadStatus;
    error?: string;
}
export interface ServiceMetadata {
    type: ServiceType;
    queryType: QueryType;
    name: string;
    id: string;
    size: number;
    graphs: ServiceGraphsInfo;
    error?: ErrorResponse;
    status: ServiceStatus;
    endpoint?: string;
    outOfSync: boolean;
    updatedAt: string;
    loadedAt?: string;
    createdAt: string;
    adminInfo?: {
        [key: string]: string | undefined;
    };
    autoResume?: boolean;
    autostopsAt?: string;
    config?: any;
    lastQueried?: string;
}
export declare type JenaReasoners = "OWL" | "RDFS";
export interface Service extends ServiceMetadata {
    foundInDocker?: boolean;
    foundInMongo?: boolean;
    memLimitBytes?: number;
    dataset?: Dataset;
}
export declare type ServiceList = Array<Service>;
export interface ServiceActions {
    start?: boolean;
    stop?: boolean;
    stopWithAutoresume?: boolean;
    recreate?: boolean;
}
export interface UpdateServiceBase {
    type: ServiceType;
    name: string;
    memoryLimit?: number | string;
}
export interface UpdateServiceVirtuoso extends UpdateServiceBase {
    type: "sparql";
}
export interface UpdateServiceElasticSearch extends UpdateServiceBase {
    type: "elasticsearch";
}
export interface UpdateServiceJena extends UpdateServiceBase {
    type: "sparql-jena";
    config: {
        reasonerType: JenaReasoners;
    };
}
export declare type UpdateService = UpdateServiceVirtuoso | UpdateServiceJena | UpdateServiceElasticSearch;
export interface Token {
    description: string;
    issuedAt: string;
    lastAccessed?: string | null;
    token?: string;
    tokenId: string;
    ownerId: string;
    scopes: Scopes;
}
export declare type CreateToken = Pick<Token, "description" | "scopes">;
export declare type FeatureToggle = "rocksRead" | "rocksWrite";
export declare type FeatureToggles = {
    [feature in FeatureToggle]: {
        value: boolean;
        label: string;
    };
};
export interface ClientConfig {
    branding: {
        name: string;
        logo: string;
        logoLg: string;
        banner?: string;
        tagline: string;
        description: string;
        welcomeMessage: string;
    };
    consoleUrl?: string;
    apiUrl?: string;
    contactEmail: string;
    prefixes: Prefixes;
    jenaServicesEnabled?: boolean;
    elasticServicesEnabled?: boolean;
    virtuosoServicesEnabled?: boolean;
    exampleDatasets?: Dataset[];
    starterDataset?: Dataset;
    enabledOauth?: string[];
    samlProviderLabel?: string;
    passwordSignup?: boolean;
    version?: string;
    statements?: number;
    buildDate: string;
    buildId: string;
    permittedSignupDomains?: string;
    upSince?: string;
    enableCaches?: {
        [cache in CacheType]: boolean;
    };
    featureToggles?: FeatureToggles;
    triplydb?: {
        numAvailableAccounts?: number;
        serviceExpirationDays?: number;
        userServiceLimit?: number;
        serviceStatementLimit?: number;
        userGraphLimit?: number;
        userStatementLimit?: number;
        userAssetByteLimit?: number;
    };
    legal?: {
        latestRequiredConsentUpdate: string;
        privacyPolicyUrl: string;
        generalTermsUrl: string;
    };
    memoryFree?: number;
    memoryTotal?: number;
    limitStatus?: "warning" | "exceeded";
    instanceUpdatedAt?: string;
    instanceStartedAt?: string;
}
export interface ClientConfigUpdate {
    branding?: {
        name?: string;
        logo?: string;
        logoLg?: string;
        tagline?: string;
        description?: string;
        welcomeMessage?: string;
    };
    contactEmail?: string;
    prefixes?: Prefixes;
    jenaServicesEnabled?: boolean;
    elasticServicesEnabled?: boolean;
    virtuosoServicesEnabled?: boolean;
    exampleDatasets?: string[];
    starterDataset?: string;
    enabledOauth?: string[];
    enabledSaml?: string[];
    passwordSignup?: boolean;
    permittedSignupDomains?: string;
    featureToggles?: {
        [feature in FeatureToggle]?: boolean;
    };
    isGeneralPublicInstanceDev?: boolean;
}
export interface RedirectRule {
    matchingMethod: "prefix" | "regexp";
    match: string;
    toDataset: Dataset | string;
    id?: string;
}
export interface AdminCacheUpdate {
    clearCache?: CacheType;
    enableCaches?: {
        [cache in CacheType]: boolean | undefined;
    };
}
export declare type CacheType = "hdt" | "describe" | "graph" | "ntriple" | "sparql" | "hdtMetadata";
export interface AdminDebugUpdate {
    namespace: string;
}
export interface DescribePaginationOptions<P = string> {
    page: number;
    predicate?: P;
    direction: "backward" | "forward";
}
export interface DescribeArguments extends Partial<DescribePaginationOptions> {
    resource: string;
    concise?: undefined;
}
export declare type Prefixes = Array<Prefix>;
export interface PrefixUpdate {
    prefixLabel: string;
    iri: string;
}
export declare type Imports = Array<Import>;
export interface Import {
    dataset: {
        ownerName?: string;
        datasetName?: string;
    };
    graphs: Array<{
        id: string;
        from: string;
        to: string;
        numberOfStatements: number;
    }>;
}
export declare type UpdateImports = Array<UpdateImport>;
export interface UpdateImport {
    dataset: {
        ownerName: string;
        datasetName: string;
    };
    graphs: Array<{
        from: string;
        to?: string;
        overwrite?: boolean;
    }>;
}
export declare type Graphs = Array<Graph>;
export interface Graph {
    graphName: string;
    id: string;
    numberOfStatements: number;
    importedAt?: string;
    uploadedAt?: string;
    importedFrom?: {
        dataset?: string;
        graphName: string;
    };
}
export declare type ClassHierarchy = {
    name: string;
    parent?: string;
    numberOfDirectInstances: number;
    prefixInfo?: PrefixInfo;
}[];
export declare type PropertyStats = {
    iri: string;
    number: number;
}[];
export declare type ClassFrequency = {
    iri: string;
    number: number;
    properties: PropertyStats;
}[];
export declare type Hooks = Array<Hook>;
export interface Hook extends HookCreate {
    id: string;
}
export interface HookCreate {
    url: string;
    active: boolean;
    payloadFormat: "JSON" | "formEncoded";
    onEvents: {
        graphImport: boolean;
        linkedDataUpload: boolean;
        fileUpload: boolean;
    };
}
export declare type WebHookTriggerRecords = Array<WebHookTriggerRecord>;
export interface WebHookTriggerRecord {
    id?: string;
    _id?: string;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    statusCode: number;
    responseText: string;
    errorCode: string;
    errorMessage: string;
    eventName: string;
    payloadFormat: string;
    payload: Object;
}
export declare type Assets = Array<Asset>;
export interface Asset {
    assetName: string;
    createdAt: string;
    identifier: string;
    versions: AssetVersion[];
    url: string;
}
export interface AssetVersion {
    id: string;
    uploadedAt: string;
    fileSize: number;
    url: string;
}
export declare type Queries = Array<Query>;
export interface Query {
    id: string;
    name: string;
    displayName?: string;
    description: string;
    owner: Account;
    accessLevel: AccessLevel;
    dataset?: Dataset;
    service: string;
    link: string;
    autoselectService: boolean;
    preferredService?: string;
    version: number;
    numberOfVersions: number;
    requestConfig?: QueryRequestConfig;
    renderConfig?: QueryRenderConfig;
    createdAt: string;
    updatedAt: string;
    variables?: VariableConfig[];
}
export interface QueryRequestConfig {
    payload: SparqlQuery;
    headers?: {
        [key: string]: string;
    };
}
export interface QueryRenderConfig {
    output: string;
    settings?: any;
}
interface CommonVariableConfig {
    name: string;
    defaultValue?: string;
    required?: boolean;
    allowedValues?: string[];
}
export interface NamedNodeConfig extends CommonVariableConfig {
    termType: "NamedNode";
}
export interface LiteralConfig extends CommonVariableConfig {
    termType: "Literal";
    datatype?: string;
    language?: string;
}
export declare type VariableConfig = NamedNodeConfig | LiteralConfig;
export interface QueryMetaUpdate {
    name?: string;
    displayName?: string;
    description?: string;
    accessLevel?: AccessLevel;
    dataset?: string;
    preferredService?: string;
    autoselectService?: boolean;
}
export declare type QueryCreate = MarkRequired<QueryMetaUpdate, "name"> & Partial<QueryVersionUpdate> & {
    generateNewName?: boolean;
};
export interface QueryVersionUpdate {
    requestConfig: QueryRequestConfig;
    renderConfig?: QueryRenderConfig;
    variables?: VariableConfig[];
}
export interface SparqlQuery {
    query: string;
    "default-graph-uri"?: string | string[];
    "named-graph-uri"?: string | string[];
    format?: string;
    timeout?: number;
    debug?: string;
}
export interface SimpleSearchQuery {
    query: string;
}
export interface AdvancedSearchQuery {
    [key: string]: any;
}
export interface HdtQuery {
    subject?: string;
    predicate?: string;
    object?: string;
    graph?: string;
    fileIndex?: number;
    offset?: number;
    expectedFileWindow?: number;
    limit?: number;
}
export interface HdtQueryShort {
    s?: string;
    p?: string;
    o?: string;
    g?: string;
    fi?: number;
    ofs?: number;
    fw?: number;
    l?: number;
}
export declare type QueryResults = Statement[];
export interface FindTermsQuery {
    pos: "subject" | "predicate" | "object" | "graph";
    graph?: string;
    q?: string;
    limit?: number;
}
export declare type FindTermsResult = string[];
export declare type QueryResult = Statement;
export declare type JobStatuses = "created" | "indexing" | "finished" | "canceled" | "error" | "downloading";
export declare type JobFileInfo = {
    fileName: string;
    fileSize: number;
    sourceFileId: string;
};
export declare type JobTypes = "upload" | "download";
export interface Job {
    baseIRI?: string;
    createdAt: string;
    datasetId: string;
    defaultGraphName?: string;
    downloadedBytes: number;
    downloadingProgress: number;
    downloadUrls?: string[];
    error?: ErrorResponse;
    files: JobFileInfo[];
    graphNames?: string[];
    indexedGraphCount: number;
    indexingProgress: number;
    jobId: string;
    jobUrl: string;
    skippedFileCount: number;
    skippedFileNames: string[];
    status: JobStatuses;
    type: JobTypes;
    updatedAt: string;
}
export interface Error {
    code?: number;
    message: string;
}
export interface Topic {
    id: string;
    iri: string;
    label: string;
    description?: string;
    parent?: string;
}
export declare type TopicUpdates = Array<TopicUpdate>;
export interface TopicUpdate {
    id?: string;
    iri?: string;
    label?: string;
    description?: string;
    parent?: string;
}
export interface SearchResults {
    datasets: Dataset[];
    accounts: Account[];
    moreDatasets: boolean;
    moreAccounts: boolean;
}
export interface ShortUrl {
    shortUrl: string;
    longUrl: string;
}
export interface LimitConfigLeaf {
    soft?: number;
    hard?: number;
}
export interface LimitJsonLeaf {
    limit?: number;
    count: number;
}
interface CountAndStatements<T> {
    count: T;
    statements: T;
}
declare type PartialIf<T, C> = C extends true ? Partial<T> : T;
declare type PartialCountAndStatementsIf<T, C> = PartialIf<CountAndStatements<T>, C>;
export interface InstanceLimits<T, C> {
    users: T;
    organizations: T;
    datasets: T;
    graphs: PartialIf<{
        unique: PartialCountAndStatementsIf<T, C>;
        all: PartialCountAndStatementsIf<T, C>;
    }, C>;
    services: Partial<{
        [key in ServiceType]: PartialCountAndStatementsIf<T, C>;
    }> & PartialIf<{
        all: PartialCountAndStatementsIf<T, C>;
    }, C>;
}
export declare type InstanceLimitsConfig = Partial<InstanceLimits<LimitConfigLeaf, true>>;
export declare type InstanceLimitsJson = InstanceLimits<LimitJsonLeaf, false>;
export declare type StoryElementType = "query" | "paragraph";
export interface StoryElement {
    id: string;
    type: StoryElementType;
    query?: Query;
    queryVersion?: number;
    paragraph?: string;
    caption?: string;
}
export interface Story {
    id: string;
    name: string;
    displayName?: string;
    owner: Account;
    accessLevel: AccessLevel;
    link: string;
    content: StoryElement[];
    createdAt: string;
    updatedAt: string;
    bannerUrl?: string;
}
export interface StoryElementUpdate {
    id?: string;
    type: StoryElementType;
    query?: string;
    queryVersion?: number;
    paragraph?: string;
    caption?: string;
}
export interface StoryUpdate {
    name?: string;
    displayName?: string;
    accessLevel?: AccessLevel;
    content?: StoryElementUpdate[];
}
export interface StoryCreate {
    name: string;
    displayName?: string;
    accessLevel?: AccessLevel;
    content?: StoryElementUpdate[];
}
export declare type RegisterOrLogin = "register" | "login";
