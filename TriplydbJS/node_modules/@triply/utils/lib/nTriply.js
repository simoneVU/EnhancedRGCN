"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rdfjsToNtriplyStream = exports.ntriplyToNquads = exports.ntriplyToN3 = exports.ntriplyToN3Term = exports.rdfjsToNtriply = void 0;
const N3 = __importStar(require("n3"));
const through = __importStar(require("through2"));
function rdfjsToNtriplyTerm(term) {
    if (term.termType === "NamedNode") {
        if (term.value.indexOf("/.well-known/genid") > 0) {
            return { termType: "BlankNode", value: term.value };
        }
        else {
            return { termType: "NamedNode", value: term.value };
        }
    }
    else if (term.termType === "BlankNode") {
        return { termType: "BlankNode", value: term.value };
    }
    let termInfo = { termType: "Literal", value: term.value };
    const asLiteral = term;
    const lang = asLiteral.language;
    if (lang)
        termInfo.language = lang;
    const datatype = asLiteral.datatype;
    if (datatype && datatype.value)
        termInfo.datatype = datatype.value;
    return termInfo;
}
function rdfjsToNtriply(n3Statement) {
    const statement = [
        rdfjsToNtriplyTerm(n3Statement.subject),
        rdfjsToNtriplyTerm(n3Statement.predicate),
        rdfjsToNtriplyTerm(n3Statement.object),
    ];
    if (n3Statement.graph.termType !== "DefaultGraph")
        statement.push(rdfjsToNtriplyTerm(n3Statement.graph));
    return statement;
}
exports.rdfjsToNtriply = rdfjsToNtriply;
function ntriplyToN3Term(term) {
    if (term.termType === "NamedNode") {
        return N3.DataFactory.namedNode(term.value);
    }
    else if (term.termType === "BlankNode") {
        if (term.value.indexOf("well-known") >= 0) {
            return N3.DataFactory.namedNode(term.value);
        }
        else {
            return N3.DataFactory.blankNode(term.value);
        }
    }
    else if (term.termType === "Literal") {
        if (term.language) {
            return N3.DataFactory.literal(term.value, term.language);
        }
        else if (term.datatype) {
            return N3.DataFactory.literal(term.value, N3.DataFactory.namedNode(term.datatype));
        }
    }
    throw new Error("Unrecognized term with value " + term.value);
}
exports.ntriplyToN3Term = ntriplyToN3Term;
function ntriplyToN3(triplyStatement) {
    const subject = ntriplyToN3Term(triplyStatement[0]);
    const predicate = ntriplyToN3Term(triplyStatement[1]);
    const object = ntriplyToN3Term(triplyStatement[2]);
    const graph = triplyStatement[3] ? ntriplyToN3Term(triplyStatement[3]) : undefined;
    return N3.DataFactory.quad(subject, predicate, object, graph);
}
exports.ntriplyToN3 = ntriplyToN3;
function ntriplyToNquads(statements) {
    return new Promise((resolve, reject) => {
        const writer = new N3.Writer();
        statements.forEach((s) => writer.addQuad(ntriplyToN3(s)));
        writer.end(function (error, result) {
            if (error)
                return reject(error);
            resolve(result);
        });
    });
}
exports.ntriplyToNquads = ntriplyToNquads;
function rdfjsToNtriplyStream() {
    return through.obj(function write(data, _encoding, cb) {
        this.push(rdfjsToNtriply(data));
        cb();
    });
}
exports.rdfjsToNtriplyStream = rdfjsToNtriplyStream;
//# sourceMappingURL=nTriply.js.map