"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lte = exports.lt = exports.gte = exports.gt = exports.isSemver = exports.increment = void 0;
const lodash_1 = require("lodash");
const positiveIntCheck = /^\d+$/;
function asPositiveInt(val) {
    if (typeof val === "string" && positiveIntCheck.test(val)) {
        return Number(val);
    }
    throw new Error(`Expected '${val}' to be a (positive) integer`);
}
function parseAndValidateCalver(calver) {
    return validate(parse(calver));
}
function parse(calver) {
    const [base, patch] = calver.split("-");
    const [year, month, versionInMonth] = base.split(".");
    try {
        return {
            yearShort: asPositiveInt(year),
            month: asPositiveInt(month),
            versionInMonth: asPositiveInt(versionInMonth),
            patch: patch ? asPositiveInt(patch) : undefined,
        };
    }
    catch (e) {
        throw new Error(`Failed to parse calver string ${calver}: ${e.message}`);
    }
}
function validate(calverOrSemver) {
    if (parsedVersionIsSemver(calverOrSemver))
        return calverOrSemver;
    if (calverOrSemver.month < 1 || calverOrSemver.month > 12)
        throw new Error(`Invalid month number ${calverOrSemver.month}`);
    return calverOrSemver;
}
function serializeCalver(calver) {
    const base = [calver.yearShort, lodash_1.padStart(String(calver.month), 2, "0"), calver.versionInMonth].join(".");
    if (calver.patch) {
        return base + `-${calver.patch}`;
    }
    return base;
}
function increment(currentVersion, opts) {
    const parsedCurrentVersion = parseAndValidateCalver(currentVersion);
    if (opts === null || opts === void 0 ? void 0 : opts.patch) {
        if (parsedCurrentVersion.patch !== undefined) {
            parsedCurrentVersion.patch++;
        }
        else {
            parsedCurrentVersion.patch = 1;
        }
        return serializeCalver(parsedCurrentVersion);
    }
    const date = (opts === null || opts === void 0 ? void 0 : opts.currentDate) || new Date();
    const currentYearShort = Number(String(date.getFullYear()).substr(2));
    const currentMonth = date.getMonth() + 1;
    if (currentYearShort !== parsedCurrentVersion.yearShort || currentMonth !== parsedCurrentVersion.month) {
        return serializeCalver({
            yearShort: currentYearShort,
            month: currentMonth,
            versionInMonth: 0,
        });
    }
    else {
        return serializeCalver({
            ...parsedCurrentVersion,
            versionInMonth: parsedCurrentVersion.versionInMonth + 1,
            patch: undefined,
        });
    }
}
exports.increment = increment;
function isSemver(version) {
    return parsedVersionIsSemver(parseAndValidateCalver(version));
}
exports.isSemver = isSemver;
function parsedVersionIsSemver(parsedVersion) {
    return parsedVersion.yearShort < 21;
}
function compare(lhs, rhs) {
    const lhsIsSemver = parsedVersionIsSemver(parseAndValidateCalver(lhs));
    const rhsIsSemver = parsedVersionIsSemver(parseAndValidateCalver(rhs));
    if (lhsIsSemver && rhsIsSemver)
        throw new Error(`Assuming ${lhs} and ${rhs} are both semver's. We do not support comparing semver alone`);
    if (lhsIsSemver)
        return -1;
    if (rhsIsSemver)
        return 1;
    return lhs.localeCompare(rhs);
}
function gt(lhs, rhs) {
    return compare(lhs, rhs) > 0;
}
exports.gt = gt;
function gte(lhs, rhs) {
    return compare(lhs, rhs) >= 0;
}
exports.gte = gte;
function lt(lhs, rhs) {
    return compare(lhs, rhs) < 0;
}
exports.lt = lt;
function lte(lhs, rhs) {
    return compare(lhs, rhs) <= 0;
}
exports.lte = lte;
//# sourceMappingURL=calver.js.map