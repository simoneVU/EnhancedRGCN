"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = __importStar(require("chai"));
const Constants_1 = require("../Constants");
var expect = chai.expect;
const fs_extra_1 = __importDefault(require("fs-extra"));
const sparqlVarUtils_1 = require("../sparqlVarUtils");
const parser = sparqlVarUtils_1.getParser();
const generator = sparqlVarUtils_1.getGenerator();
function normalizeQuery(query) {
    return generator.stringify(parser.parse(query)).replace(sparqlVarUtils_1.REGEX_REPLACE_STRING_DATATYPE, "");
}
function testInject(query, variableDefinitions, args) {
    expect(sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(query.original, { variableDefinitions, variableValues: args })).to.equal(normalizeQuery(query.expected), "failed to inject variables into query using sparql parser");
}
describe("SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR", function () {
    it("should be strictly smaller than one.", function () {
        expect(Constants_1.SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR).to.be.below(1);
    });
    it("should be strictly larger than zero.", function () {
        expect(Constants_1.SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR).to.be.above(0);
    });
});
describe("Sparql var utils", () => {
    describe("SparqlJS parser tests", function () {
        it("https://issues.triply.cc/issues/4485", async function () {
            const query = await fs_extra_1.default.readFile("./src/__tests__/data/invalidQuery_4757.sparql", "utf-8");
            expect(() => parser.parse(query)).to.throw("Parse error");
        });
    });
    describe("Replace query variables", () => {
        it("Sparqlparser output should not contain a datatype", function () {
            expect(sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?x ?y "amsterdam"}`, {
                variableDefinitions: [],
                variableValues: {},
            })).not.to.contain("http://www.w3.org/2001/XMLSchema#string");
        });
        it(`Should not throw error on undefined value`, () => {
            sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`
          SELECT * WHERE {
            VALUES ( ?a ?b ) {
              ( "IndividualDifference" UNDEF)
            }
          }`, { variableDefinitions: [{ name: "a", defaultValue: "http://bla", termType: "NamedNode" }], variableValues: {} });
        });
        it(`Should not apply sparql parser when no variables are defined`, () => {
            expect(sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`someIllegalQuery`, { variableDefinitions: [], variableValues: {} })).to.equal("someIllegalQuery");
        });
        it.skip(`Should not throw error on valid property path`, () => {
            sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`
prefix : <https://ex.com/>

select * {
:a :a :a ;
  :a [
    :a/:a :a
  ] .
}
`, { variableDefinitions: [{ name: "a", defaultValue: "http://bla", termType: "NamedNode" }], variableValues: {} });
        });
        it(`Check replace`, () => {
            testInject({
                original: `SELECT * WHERE {
            ?s ?p ?o.
            ?s ?p $x.
          }
          `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "amsterdam".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: true,
                },
            ], {
                x: "amsterdam",
            });
        });
        it(`Should use default values`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "amsterdam".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: true,
                    defaultValue: "amsterdam",
                },
            ], {});
        });
        it(`Keep original prefix declarations when possible`, () => {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery("prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT * WHERE { ?s ?p ?o . ?s ?p $x . }", {
                variableDefinitions: [
                    {
                        name: "x",
                        termType: "Literal",
                        required: true,
                    },
                ],
                variableValues: {
                    x: "amsterdam",
                },
            });
            expect(result).to.contain("PREFIX rdf:");
        });
        it("Should throw BadArgumentsError when passing inapplicable arg", () => {
            let e;
            try {
                sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`ask{?s?p?o}`, { variableDefinitions: [], variableValues: {}, page: 1 });
            }
            catch (_e) {
                e = _e;
            }
            expect(e).to.be.instanceof(sparqlVarUtils_1.BadArgumentsError);
        });
        it(`Should throw when prefix is not defined`, () => {
            const query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT * WHERE {
          ?s bif:contains ?o.
          ?s ?p ?x.
        }
      `;
            let e;
            try {
                sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(query, {
                    variableDefinitions: [{ name: "s", termType: "NamedNode", defaultValue: "https://bla" }],
                    variableValues: {},
                });
            }
            catch (_e) {
                e = _e;
            }
            expect(e === null || e === void 0 ? void 0 : e.message).to.contain("Unknown prefix");
        });
        it(`Don't change variable when not defined`, () => {
            const variables = [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                },
            ];
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p ?x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p ?x.
            }
            `,
            }, variables, {});
        });
        it(`Append language tag`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "newX"@en.
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                    language: "en",
                },
            ], { x: "newX" });
        });
        it(`Append datatype`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1"^^<http://whatever>.
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                    datatype: "http://whatever",
                },
            ], { x: "1" });
        });
        it(`Ignore datatype if it's a string`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                    datatype: "http://www.w3.org/2001/XMLSchema#string",
                },
            ], { x: "1" });
        });
        it(`Dont append datatype if not set`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                },
            ], { x: "1" });
        });
        it(`[parser method] Dont append when xsd is added a prefix`, () => {
            testInject({
                original: `
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                },
            ], { x: "1" });
        });
        it(`Deal with hashed IRIs as query argument`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p <https://bla#bla>.
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "NamedNode",
                    required: false,
                },
            ], { x: "https://bla#bla" });
        });
        it(`Only change variables when sparql-parser is used`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p "$o".
              ?s ?p $o.
            }`,
                expected: `
            SELECT * WHERE {
              ?s ?p "$o".
              ?s ?p "amsterdam".
            }`,
            }, [
                {
                    name: "o",
                    termType: "Literal",
                    required: true,
                },
            ], { o: "amsterdam" });
        });
        it(`Match full queryname`, () => {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?objects.
              ?s ?p ?obje.
              ?s ?p ?o.
            }`,
                expected: `
            SELECT * WHERE {
              ?s ?p ?objects.
              ?s ?p "amsterdam".
              ?s ?p ?o.
            }`,
            }, [
                {
                    name: "obje",
                    termType: "Literal",
                    required: true,
                },
            ], { obje: "amsterdam" });
        });
        it(`Change both $ and ? variables (Naive)`, () => {
            testInject({
                original: `
            SELECT (count(?s) as ?c) {
              ?s $p ?o.
            }
            `,
                expected: `
            SELECT (count(?s) as ?c) {
              ?s <canada:ontario> "amsterdam".
            }
            `,
            }, [
                {
                    name: "p",
                    termType: "NamedNode",
                    required: false,
                },
                {
                    name: "o",
                    termType: "Literal",
                    required: false,
                },
            ], { p: "canada:ontario", o: "amsterdam" });
        });
    });
    describe("Limit and offset", () => {
        it("Should inject limit and offset into SELECT when given", function () {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?x ?y "amsterdam"}`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
                pageSize: 3,
            });
            expect(result).to.contain("LIMIT 3");
            expect(result).to.contain("OFFSET 3");
        });
        it("Should inject limit and offset into DESRIBE when given", function () {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`DESCRIBE <a:a>`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
                pageSize: 3,
            });
            expect(result).to.contain("LIMIT 3");
            expect(result).to.contain("OFFSET 3");
        });
        it("Should inject limit and offset into CONSTRUCT when given", function () {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`CONSTRUCT {?s?p?o} WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
                pageSize: 3,
            });
            expect(result).to.contain("LIMIT 3");
            expect(result).to.contain("OFFSET 3");
        });
        it("Should not inject limit or offset when neither page or pageSize is given", function () {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
            });
            expect(result).not.to.contain("LIMIT");
            expect(result).not.to.contain("OFFSET");
        });
        it("Should handle case where page is given but pageSize is not", function () {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
            });
            expect(result).to.contain(`LIMIT ${Constants_1.SPARQL_RESULT_DEFAULT_PAGE_SIZE}`);
            expect(result).to.contain(`OFFSET ${Constants_1.SPARQL_RESULT_DEFAULT_PAGE_SIZE}`);
        });
        it("Should handle case where pageSize is given but page is not", function () {
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
                pageSize: 50,
            });
            expect(result).to.contain("LIMIT 50");
            expect(result).not.to.contain("OFFSET");
        });
        it("Running a query with blank node twice should return the same bnode identifier", function () {
            const testQuery = `SELECT * WHERE {[]?p?o}`;
            const result = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(testQuery, {
                variableDefinitions: [],
                variableValues: {},
                pageSize: 50,
            });
            const result2 = sparqlVarUtils_1.parseAndInjectVariablesIntoQuery(testQuery, {
                variableDefinitions: [],
                variableValues: {},
                pageSize: 50,
            });
            expect(result).to.equal(result2);
        });
    });
    describe("Detecting a CONSTRUCT query", function () {
        it("should mark a CONSTRUCT query as being one", function () {
            expect(sparqlVarUtils_1.parseAndInjectVariablesIntoQueryAndGetInfo(`CONSTRUCT {?s?p?o} WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
            }).isConstructQuery).to.equal(true);
        });
        it("should mark a SELECT query as not being a CONSTRUCT query", function () {
            expect(sparqlVarUtils_1.parseAndInjectVariablesIntoQueryAndGetInfo(`SELECT * WHERE {?x ?y "amsterdam"}`, {
                variableDefinitions: [],
                variableValues: {},
            }).isConstructQuery).to.equal(false);
        });
        it("should mark a DESRIBE query as not being a CONSTRUCT query", function () {
            expect(sparqlVarUtils_1.parseAndInjectVariablesIntoQueryAndGetInfo(`DESCRIBE <a:a>`, {
                variableDefinitions: [],
                variableValues: {},
            }).isConstructQuery).to.equal(false);
        });
    });
    describe("Filter term suggestions", () => {
        it("should filter on datatype", () => {
            const filtered = sparqlVarUtils_1.filterSuggestions({
                name: "whatever",
                termType: "Literal",
            }, [`"a"@en`, `"b"`]);
            expect(filtered).to.have.lengthOf(1);
            expect(filtered[0]).to.equal("b");
        });
    });
});
//# sourceMappingURL=sparqlVarUtils-test.js.map