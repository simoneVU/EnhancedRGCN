import * as N3 from "n3";
import * as RdfJs from "rdf-js";
export type Statements = Statement[];
import * as through from "through2";
import * as stream from "stream";
export type Statement = [Term, Term, Term, Term] | [Term, Term, Term];

export interface Term {
  termType: "NamedNode" | "BlankNode" | "Literal";
  value: string;
  language?: string;
  datatype?: string;
}
function rdfjsToNtriplyTerm(term: RdfJs.Term): Term {
  if (term.termType === "NamedNode") {
    if (term.value.indexOf("/.well-known/genid") > 0) {
      return { termType: "BlankNode", value: term.value };
    } else {
      return { termType: "NamedNode", value: term.value };
    }
  } else if (term.termType === "BlankNode") {
    return { termType: "BlankNode", value: term.value };
  }
  let termInfo: Term = { termType: "Literal", value: term.value };
  const asLiteral = term as N3.Literal;
  const lang = asLiteral.language;
  if (lang) termInfo.language = lang;
  const datatype = asLiteral.datatype;
  if (datatype && datatype.value) termInfo.datatype = datatype.value;
  return termInfo;
}

export function rdfjsToNtriply(n3Statement: RdfJs.Quad): Statement {
  const statement: Statement = [
    rdfjsToNtriplyTerm(n3Statement.subject),
    rdfjsToNtriplyTerm(n3Statement.predicate),
    rdfjsToNtriplyTerm(n3Statement.object),
  ];
  // #2607 Triples are always returned as Quads with a default graph when none is specified
  if (n3Statement.graph.termType !== "DefaultGraph") statement.push(rdfjsToNtriplyTerm(n3Statement.graph));
  return statement;
}

export function ntriplyToN3Term(term: Term): N3.Term {
  if (term.termType === "NamedNode") {
    return N3.DataFactory.namedNode(term.value);
  } else if (term.termType === "BlankNode") {
    if (term.value.indexOf("well-known") >= 0) {
      return N3.DataFactory.namedNode(term.value);
    } else {
      return N3.DataFactory.blankNode(term.value);
    }
  } else if (term.termType === "Literal") {
    if (term.language) {
      return N3.DataFactory.literal(term.value, term.language);
    } else if (term.datatype) {
      return N3.DataFactory.literal(term.value, N3.DataFactory.namedNode(term.datatype));
    }
  }
  throw new Error("Unrecognized term with value " + term.value);
}
export function ntriplyToN3(triplyStatement: Statement) {
  const subject = ntriplyToN3Term(triplyStatement[0]) as N3.NamedNode | N3.BlankNode;
  const predicate = ntriplyToN3Term(triplyStatement[1]) as N3.NamedNode;
  const object = ntriplyToN3Term(triplyStatement[2]) as N3.NamedNode | N3.BlankNode | N3.Literal;
  const graph = triplyStatement[3] ? (ntriplyToN3Term(triplyStatement[3]) as N3.NamedNode) : undefined;
  return N3.DataFactory.quad(subject, predicate, object, graph);
}
export function ntriplyToNquads(statements: Statements): Promise<string> {
  return new Promise<string>((resolve, reject) => {
    const writer = new N3.Writer();
    statements.forEach((s) => writer.addQuad(ntriplyToN3(s)));
    writer.end(function (error: Error, result: string) {
      if (error) return reject(error);
      resolve(result);
    });
  });
}

export function rdfjsToNtriplyStream() {
  return through.obj(function write(this: stream.Duplex, data: RdfJs.Quad, _encoding: any, cb: Function) {
    this.push(rdfjsToNtriply(data));
    cb();
  });
}
