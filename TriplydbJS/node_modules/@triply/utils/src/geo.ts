const parseWellknown = require("wellknown");

export type Wkt =
  | {
      type: "GeometryCollection";
      geometries: Wkt[];
    }
  | {
      type: "Point";
      coordinates: number[];
    }
  | {
      type: "MultiPoint" | "LineString";
      coordinates: number[][];
    }
  | {
      type: "Polygon" | "MultiLineString";
      coordinates: number[][][];
    }
  | {
      type: "MultiPolygon";
      coordinates: number[][][][];
    };

export type Point = {
  longitude: number;
  latitude: number;
  crs?: string;
};

const CRS_REGEX = new RegExp("^<(.*)>s*(.*)");
/**
 * Parses wkt
 * @param wktString
 * @returns  Wkt object
 */
export function parseWkt(wktString: string, supportedCrs: string[] = ["http://www.opengis.net/def/crs/EPSG/0/4326"]) {
  if (!wktString) throw new Error("No wkt string given.");
  wktString = wktString.trim();
  let crs = undefined;
  if (wktString[0] === "<") {
    const matches = wktString.match(CRS_REGEX);
    if (!matches) {
      //This isnt a wkt, and not a CRS-prefixes wkt
      throw new Error("Could not parse wkt.");
    }
    crs = matches[1];
    if (supportedCrs.indexOf(crs) === -1) throw new Error(`CRS ${crs} is not supported.`);
    wktString = matches[2].trim();
  }
  const parsedWkt: Wkt = parseWellknown(wktString);
  validateWkt(parsedWkt);
  return {
    wkt: parsedWkt,
    crs,
  };
}

export function isValidWkt(wktString: string, supportedCrs: string[] = ["http://www.opengis.net/def/crs/EPSG/0/4326"]) {
  try {
    parseWkt(wktString, supportedCrs);
    return true;
  } catch {
    return false;
  }
}
export function validateWkt(wkt: Wkt) {
  if (!wkt) throw new Error("Could not parse wkt.");
  switch (wkt.type) {
    case "Point":
      if (wkt.coordinates.length === 1) throw new Error("Invalid WKT point");
      break;
    case "MultiPoint":
    case "LineString":
      wkt.coordinates.forEach((coordinate) => {
        if (coordinate === undefined || !coordinate.length) throw new Error("Invalid WKT segment");
      });
      break;
    case "Polygon":
    case "MultiLineString":
      wkt.coordinates.forEach((point) => {
        if (point === undefined || !point.length) throw new Error("Invalid WKT segment");
        point.forEach((coordinate) => {
          if (coordinate === undefined || !coordinate.length) {
            throw new Error("Invalid WKT segment");
          }
        });
      });
      break;
    case "MultiPolygon":
      wkt.coordinates.forEach((polygon) => {
        if (polygon === undefined || !polygon.length) throw new Error("Invalid WKT segment");
        polygon.forEach((point) => {
          if (point === undefined || !point.length) throw new Error("Invalid WKT segment");
          point.forEach((coordinate) => {
            if (coordinate === undefined || !coordinate.length) {
              throw new Error("Invalid WKT segment");
            }
          });
        });
      });
      break;
    case "GeometryCollection":
      wkt.geometries.forEach((geom) => validateWkt(geom));
      break;
    default:
      throw new Error(`Unknown wkt type ${(wkt as any).type}`);
  }
}

/**
 * Gets first point from wkt string
 * @param wktString a wkt string
 * @returns  the first point of the wkt string
 */
export function getFirstPointFromWktString(wktString: string) {
  try {
    const parsedWkt = parseWkt(wktString);
    const firstPoint = getFirstPointFromWkt(parsedWkt.wkt);
    if (!firstPoint) return firstPoint;
    if (parsedWkt.crs) firstPoint.crs = parsedWkt.crs;
    return firstPoint;
  } catch {
    return undefined;
  }
}

/**
 * Gets fist point from wkt
 * @param wkt a wkt object
 * @returns the first point of a wkt
 */
export function getFirstPointFromWkt(wkt: Wkt): Point | undefined {
  try {
    switch (wkt.type) {
      case "Point":
        return { longitude: wkt.coordinates[0], latitude: wkt.coordinates[1] };
      case "MultiPoint":
      case "LineString":
        return { longitude: wkt.coordinates[0][0], latitude: wkt.coordinates[0][1] };
      case "Polygon":
      case "MultiLineString":
        return { longitude: wkt.coordinates[0][0][0], latitude: wkt.coordinates[0][0][1] };
      case "MultiPolygon":
        return { longitude: wkt.coordinates[0][0][0][0], latitude: wkt.coordinates[0][0][0][1] };
      case "GeometryCollection":
        return getFirstPointFromWkt(wkt.geometries[0]);
      default: {
        console.info(`Unknown wkt type ${(wkt as any).type}`);
        return undefined;
      }
    }
  } catch (e) {
    return undefined;
  }
}
export default parseWellknown;
