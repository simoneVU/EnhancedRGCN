import { padStart } from "lodash";

interface ParsedCalver {
  yearShort: number;
  month: number;
  versionInMonth: number;
  patch?: number;
}
const positiveIntCheck = /^\d+$/;
function asPositiveInt(val?: string) {
  if (typeof val === "string" && positiveIntCheck.test(val)) {
    return Number(val);
  }
  throw new Error(`Expected '${val}' to be a (positive) integer`);
}

function parseAndValidateCalver(calver: string): ParsedCalver {
  return validate(parse(calver));
}
function parse(calver: string): ParsedCalver {
  const [base, patch] = calver.split("-");

  const [year, month, versionInMonth] = base.split(".");

  try {
    return {
      yearShort: asPositiveInt(year),
      month: asPositiveInt(month),
      versionInMonth: asPositiveInt(versionInMonth),
      patch: patch ? asPositiveInt(patch) : undefined,
    };
  } catch (e) {
    throw new Error(`Failed to parse calver string ${calver}: ${e.message}`);
  }
}

function validate(calverOrSemver: ParsedCalver): ParsedCalver {
  if (parsedVersionIsSemver(calverOrSemver)) return calverOrSemver; // Dont validate this, it's semver
  if (calverOrSemver.month < 1 || calverOrSemver.month > 12)
    throw new Error(`Invalid month number ${calverOrSemver.month}`);
  return calverOrSemver;
}
function serializeCalver(calver: ParsedCalver): string {
  const base = [calver.yearShort, padStart(String(calver.month), 2, "0"), calver.versionInMonth].join(".");
  if (calver.patch) {
    return base + `-${calver.patch}`;
  }
  return base;
}

export function increment(currentVersion: string, opts?: { patch?: boolean; currentDate?: Date }) {
  /**
   * If we want to patch a release, dont modify the calver part. Only increment the patch version
   */
  const parsedCurrentVersion = parseAndValidateCalver(currentVersion);
  if (opts?.patch) {
    if (parsedCurrentVersion.patch !== undefined) {
      parsedCurrentVersion.patch++;
    } else {
      parsedCurrentVersion.patch = 1;
    }
    return serializeCalver(parsedCurrentVersion);
  }
  const date = opts?.currentDate || new Date();
  const currentYearShort = Number(String(date.getFullYear()).substr(2));
  const currentMonth = date.getMonth() + 1; // dates by default are zero-indexed
  if (currentYearShort !== parsedCurrentVersion.yearShort || currentMonth !== parsedCurrentVersion.month) {
    // This also triggers when we pass a semver (we're assuming the major-version if never 21)
    return serializeCalver({
      yearShort: currentYearShort,
      month: currentMonth,
      versionInMonth: 0,
    });
  } else {
    // Incrementing versionInMonth
    return serializeCalver({
      ...parsedCurrentVersion,
      versionInMonth: parsedCurrentVersion.versionInMonth + 1,
      patch: undefined,
    });
  }
}

export function isSemver(version: string) {
  return parsedVersionIsSemver(parseAndValidateCalver(version));
}
function parsedVersionIsSemver(parsedVersion: ParsedCalver): boolean {
  /**
   * Assuming we're not using major-versions of 21 or higher
   */
  return parsedVersion.yearShort < 21;
}
function compare(lhs: string, rhs: string) {
  const lhsIsSemver = parsedVersionIsSemver(parseAndValidateCalver(lhs));
  const rhsIsSemver = parsedVersionIsSemver(parseAndValidateCalver(rhs));
  if (lhsIsSemver && rhsIsSemver)
    throw new Error(`Assuming ${lhs} and ${rhs} are both semver's. We do not support comparing semver alone`);

  if (lhsIsSemver) return -1;
  if (rhsIsSemver) return 1;
  // simple string comparison suffices when we know we're comparing our calver versions
  return lhs.localeCompare(rhs);
}

export function gt(lhs: string, rhs: string) {
  return compare(lhs, rhs) > 0;
}
export function gte(lhs: string, rhs: string) {
  return compare(lhs, rhs) >= 0;
}
export function lt(lhs: string, rhs: string) {
  return compare(lhs, rhs) < 0;
}
export function lte(lhs: string, rhs: string) {
  return compare(lhs, rhs) <= 0;
}
