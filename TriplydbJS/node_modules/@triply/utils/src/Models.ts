import { Statement, Prefix, PrefixInfo } from "./";

import { SERVICE_TYPES, QUERY_TYPES } from "./Constants";
import { MarkRequired } from "ts-essentials";
export { Statement } from "./";
export { Prefix, PrefixInfo } from "./";

export interface ParsingContext {
  line: number;
  lines?: { [line: number]: string };
  token?: Token;
  previousToken?: Token;
}
export interface ErrorResponse {
  code?: number;
  message: string;
  errors?: ErrorResponse[];
  serverError?: string;
  files?: string[];
  parsingContext?: ParsingContext;
  failedFileType?:
    | "xml"
    | "nquads"
    | "ntriples"
    | "turtle"
    | "trig"
    | "bzip"
    | "gzip"
    | "zip"
    | "rar"
    | "7z"
    | "tar"
    | string;
}
export interface JwtPayloadReserved {
  //part of spec
  iss: string; //issuer
  jti: string; //unique jwt id, used for revocation
  exp: number; //expires in seconds
  iat?: number; //issued at, seconds
}
export interface JwtPayloadCustom {
  imp?: string; //imporsonated user
  uid: string; //user id
  aud?: string; //audience
  sub?: string; //subject
  // sc: Scopes; //scopes
}
//a means 'all'
export interface Scopes {
  acc?: Array<"pub" | "priv" | "a">; //dataset access
  ds?: Array<"c" | "r" | "u" | "d" | "a">; //dataset
  us?: Array<"u" | "a">; //user
  tok?: Array<"c" | "a">; //token,
  cust?: string[]; //custom tokens
}

export interface JwtPayload extends JwtPayloadCustom, JwtPayloadReserved {}

export type OrgRole = "owner" | "member";
export interface OrgMember {
  role: OrgRole;
  user: User;
  createdAt: string;
  updatedAt: string;
}
export interface OrgMemberUpdate {
  role: OrgRole;
}
/**
 * Account defs
 */
export type AccountType = "user" | "org";

export type PinnedItemType = "Dataset" | "Query" | "Story";

export interface PinnedDataset {
  type: "Dataset";
  item: DatasetPublic;
}
export interface PinnedQuery {
  type: "Query";
  item: Query;
}
export interface PinnedStory {
  type: "Story";
  item: Story;
}
export type PinnedItem = PinnedDataset | PinnedQuery | PinnedStory;
export interface PinnedItemUpdate {
  type: PinnedItemType;
  item: string;
}

export interface AccountPublic {
  avatarUrl?: string;
  accountName: string;
  name?: string;
  description: string;
  uid: string;
  createdAt: string;
  pinnedItems?: PinnedItem[];
  datasetCount?: number;
  queryCount?: number;
  storyCount?: number;
}
export interface AccountPrivate {
  email?: string;
  updatedAt: string;
}
export interface AccountUpdate {
  name?: string;
  email?: string;
  accountName?: string;
  pinnedItems?: PinnedItemUpdate[];
  description?: string;
}
export type Account = User | Org;

/**
 * User defs
 */

export type UserRole = "superAdmin" | "siteAdmin" | "regular" | "light" | "none";
export interface UserPublic {
  type: "user";
  role?: UserRole;
  orgs?: Org[];
}
export interface UserPrivate {
  impersonatedBy?: string;
  authMethod: string;
  verified: boolean;
  legalConsent?: boolean;
  disabled: boolean;
  expiresAt?: string;
  role?: UserRole;
  lastActivity?: string;
  usageInfo?: {
    services: string[];
    graphCount: number;
    statementCount: number;
    assetBytes: number;
  };
}
export interface UserUpdate extends AccountUpdate {
  role?: UserRole;
  disabled?: boolean;
  expiresAt?: string;
  verified?: boolean;
  legalConsent?: boolean;
}
export type User = Partial<AccountPrivate> & Partial<UserPrivate> & AccountPublic & UserPublic;

export interface BulkUserReport {
  success: number;
  errors: { account: string; message: string }[];
}

/**
 * Org defs
 */
export interface OrgPublic {
  type: "org";
  members?: OrgMember[];
}
export interface OrgPrivate {}
export interface OrgUpdate extends AccountUpdate {}
export type Org = Partial<AccountPrivate> & Partial<OrgPrivate> & AccountPublic & OrgPublic;

export type AccessLevel = "public" | "private" | "internal";
export type DatasetLicenses = "PDDL" | "ODC-By" | "ODC-ODbL" | "CC0 1.0" | "CC-BY-SA" | "GFDL" | null;

export type Dataset = DatasetPublic;
export interface DatasetPublic {
  id: string;
  name: string;
  description: string;
  displayName: string;
  avatarUrl: string | undefined;
  owner: Account;
  accessLevel: AccessLevel;
  license: DatasetLicenses;
  createdAt: string;
  updatedAt: string;
  graphCount: number;
  statements: number;
  lastGraphsUpdateTime: string;
  serviceCount: number;
  assetCount: number;
  topics: Topic[];
  implicitTopics: Topic[];
  exampleResources: string[];
}

export interface DatasetVerbose extends DatasetPublic {
  services: Service[];
  largestGraphs: Graphs;
  openJobs?: Job[];
}

export interface UpdateDataset {
  displayName?: string;
  description?: string;
  name?: string;
  accessLevel?: AccessLevel;
  license?: DatasetLicenses;
  topics?: string[];
  exampleResources?: string[];
}

export interface NewDataset {
  name?: string;
  displayName?: string;
  toAccount?: string;
  description?: string;
  accessLevel?: AccessLevel;
  license?: DatasetLicenses;
}

export type ServiceType = typeof SERVICE_TYPES[number];

export type QueryType = typeof QUERY_TYPES[number];
export type ServiceStatus = "starting" | "running" | "stopping" | "stopped" | "removing" | "updating" | "error";
export type LoadStatus = "loaded" | "loading" | "error" | "notLoaded";
//docker states:
// 'running' | 'created' | 'exited' | 'paused' | 'restarting',
export interface ServiceGraphsInfo {
  [graphName: string]: ServiceGraphInfo;
}
export interface ServiceGraphInfo {
  status: LoadStatus;
  error?: string;
}
export interface ServiceMetadata {
  type: ServiceType;
  queryType: QueryType;
  name: string;
  id: string;
  size: number;
  graphs: ServiceGraphsInfo;
  error?: ErrorResponse;
  status: ServiceStatus;
  endpoint?: string;
  outOfSync: boolean;
  updatedAt: string;
  loadedAt?: string;
  createdAt: string;
  adminInfo?: { [key: string]: string | undefined };
  autoResume?: boolean;
  autostopsAt?: string;
  config?: any;
  lastQueried?: string;
}

export type JenaReasoners = "OWL" | "RDFS";

export interface Service extends ServiceMetadata {
  //admin only
  foundInDocker?: boolean;
  foundInMongo?: boolean;
  memLimitBytes?: number;
  dataset?: Dataset;
}

export type ServiceList = Array<Service>;
export interface ServiceActions {
  start?: boolean;
  stop?: boolean;
  stopWithAutoresume?: boolean;
  recreate?: boolean;
}
export interface UpdateServiceBase {
  type: ServiceType;
  name: string;
  memoryLimit?: number | string;
}
export interface UpdateServiceVirtuoso extends UpdateServiceBase {
  type: "sparql";
}
export interface UpdateServiceElasticSearch extends UpdateServiceBase {
  type: "elasticsearch";
}
export interface UpdateServiceJena extends UpdateServiceBase {
  type: "sparql-jena";
  config: {
    reasonerType: JenaReasoners;
  };
}
export type UpdateService = UpdateServiceVirtuoso | UpdateServiceJena | UpdateServiceElasticSearch;
export interface Token {
  description: string;
  issuedAt: string;
  lastAccessed?: string | null;
  token?: string;
  tokenId: string;
  ownerId: string;
  scopes: Scopes;
}
export type CreateToken = Pick<Token, "description" | "scopes">;

export type FeatureToggle = "rocksRead" | "rocksWrite";
export type FeatureToggles = {
  [feature in FeatureToggle]: {
    value: boolean;
    label: string;
  };
};
export interface ClientConfig {
  branding: {
    name: string;
    logo: string;
    logoLg: string;
    banner?: string;
    tagline: string;
    description: string;
    welcomeMessage: string;
  };
  consoleUrl?: string;
  apiUrl?: string;
  contactEmail: string;
  prefixes: Prefixes;
  jenaServicesEnabled?: boolean;
  elasticServicesEnabled?: boolean;
  virtuosoServicesEnabled?: boolean;
  exampleDatasets?: Dataset[];
  starterDataset?: Dataset;
  enabledOauth?: string[];
  samlProviderLabel?: string;
  passwordSignup?: boolean;
  version?: string;
  statements?: number;
  buildDate: string;
  buildId: string;
  //only used by admins
  permittedSignupDomains?: string;
  upSince?: string;
  enableCaches?: { [cache in CacheType]: boolean };
  featureToggles?: FeatureToggles;
  triplydb?: {
    numAvailableAccounts?: number;
    serviceExpirationDays?: number;
    userServiceLimit?: number;
    serviceStatementLimit?: number;
    userGraphLimit?: number;
    userStatementLimit?: number;
    userAssetByteLimit?: number;
  };
  legal?: {
    latestRequiredConsentUpdate: string;
    privacyPolicyUrl: string;
    generalTermsUrl: string;
  };
  memoryFree?: number;
  memoryTotal?: number;
  limitStatus?: "warning" | "exceeded";
  instanceUpdatedAt?: string;
  instanceStartedAt?: string;
}
export interface ClientConfigUpdate {
  branding?: {
    name?: string;
    logo?: string;
    logoLg?: string;
    tagline?: string;
    description?: string;
    welcomeMessage?: string;
  };
  contactEmail?: string;
  prefixes?: Prefixes;
  jenaServicesEnabled?: boolean;
  elasticServicesEnabled?: boolean;
  virtuosoServicesEnabled?: boolean;
  exampleDatasets?: string[];
  starterDataset?: string;
  enabledOauth?: string[];
  enabledSaml?: string[];
  passwordSignup?: boolean;
  permittedSignupDomains?: string;
  featureToggles?: { [feature in FeatureToggle]?: boolean };
  isGeneralPublicInstanceDev?: boolean;
}
export interface RedirectRule {
  matchingMethod: "prefix" | "regexp";
  match: string;
  toDataset: Dataset | string;
  id?: string;
}
export interface AdminCacheUpdate {
  clearCache?: CacheType;
  enableCaches?: { [cache in CacheType]: boolean | undefined };
}
export type CacheType = "hdt" | "describe" | "graph" | "ntriple" | "sparql" | "hdtMetadata";
export interface AdminDebugUpdate {
  namespace: string;
}

export interface DescribePaginationOptions<P = string> {
  page: number;
  predicate?: P;
  direction: "backward" | "forward";
}

export interface DescribeArguments extends Partial<DescribePaginationOptions> {
  resource: string;
  concise?: undefined;
}

export type Prefixes = Array<Prefix>;

export interface PrefixUpdate {
  prefixLabel: string;
  iri: string;
}

export type Imports = Array<Import>;
export interface Import {
  dataset: { ownerName?: string; datasetName?: string };
  graphs: Array<{ id: string; from: string; to: string; numberOfStatements: number }>;
}

export type UpdateImports = Array<UpdateImport>;
export interface UpdateImport {
  dataset: { ownerName: string; datasetName: string };
  graphs: Array<{ from: string; to?: string; overwrite?: boolean }>;
}

export type Graphs = Array<Graph>;
export interface Graph {
  graphName: string;
  id: string;
  numberOfStatements: number;
  importedAt?: string;
  uploadedAt?: string;
  importedFrom?: { dataset?: string; graphName: string };
}

export type ClassHierarchy = {
  name: string;
  parent?: string;
  numberOfDirectInstances: number;
  prefixInfo?: PrefixInfo;
}[];
export type PropertyStats = { iri: string; number: number }[];
export type ClassFrequency = { iri: string; number: number; properties: PropertyStats }[];

export type Hooks = Array<Hook>;
export interface Hook extends HookCreate {
  id: string;
}
export interface HookCreate {
  url: string;
  active: boolean;
  payloadFormat: "JSON" | "formEncoded";
  onEvents: {
    graphImport: boolean;
    linkedDataUpload: boolean;
    fileUpload: boolean;
  };
}

export type WebHookTriggerRecords = Array<WebHookTriggerRecord>;
export interface WebHookTriggerRecord {
  id?: string;
  _id?: string;
  url: string;
  createdAt?: string;
  updatedAt?: string;
  statusCode: number;
  responseText: string;
  errorCode: string;
  errorMessage: string;
  eventName: string;
  payloadFormat: string;
  payload: Object;
}

export type Assets = Array<Asset>;
export interface Asset {
  assetName: string;
  createdAt: string;
  identifier: string;
  versions: AssetVersion[];
  url: string;
}
export interface AssetVersion {
  id: string;
  uploadedAt: string;
  fileSize: number;
  url: string;
}

export type Queries = Array<Query>;
export interface Query {
  id: string;
  name: string;
  displayName?: string;
  description: string;
  owner: Account;
  accessLevel: AccessLevel;
  dataset?: Dataset;
  service: string;
  link: string;
  autoselectService: boolean;
  preferredService?: string;
  version: number;
  numberOfVersions: number;
  requestConfig?: QueryRequestConfig;
  renderConfig?: QueryRenderConfig;
  createdAt: string;
  updatedAt: string;
  variables?: VariableConfig[];
}
export interface QueryRequestConfig {
  payload: SparqlQuery;
  headers?: { [key: string]: string };
}
export interface QueryRenderConfig {
  output: string;
  settings?: any;
}

interface CommonVariableConfig {
  name: string;
  defaultValue?: string;
  required?: boolean;
  allowedValues?: string[];
}
export interface NamedNodeConfig extends CommonVariableConfig {
  termType: "NamedNode";
}
export interface LiteralConfig extends CommonVariableConfig {
  termType: "Literal";
  datatype?: string;
  language?: string;
}
export type VariableConfig = NamedNodeConfig | LiteralConfig;

export interface QueryMetaUpdate {
  name?: string;
  displayName?: string;
  description?: string;
  accessLevel?: AccessLevel;
  dataset?: string;
  preferredService?: string;
  autoselectService?: boolean;
}

export type QueryCreate = MarkRequired<QueryMetaUpdate, "name"> &
  Partial<QueryVersionUpdate> & { generateNewName?: boolean };

export interface QueryVersionUpdate {
  requestConfig: QueryRequestConfig;
  renderConfig?: QueryRenderConfig;
  variables?: VariableConfig[];
}

export interface SparqlQuery {
  query: string;
  "default-graph-uri"?: string | string[];
  "named-graph-uri"?: string | string[];
  format?: string;
  timeout?: number;
  debug?: string;
}
export interface SimpleSearchQuery {
  query: string;
}
export interface AdvancedSearchQuery {
  // The ES DSL API is large and ES doesn't provide TS types.
  // See query DSL docs:
  // https://elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html
  [key: string]: any;
}
export interface HdtQuery {
  subject?: string;
  predicate?: string;
  object?: string;
  graph?: string;
  // file
  fileIndex?: number;
  offset?: number;
  expectedFileWindow?: number;
  limit?: number;
}
export interface HdtQueryShort {
  s?: string;
  p?: string;
  o?: string;
  g?: string;
  fi?: number; //file index
  ofs?: number; //offset in first file
  fw?: number; //file window
  l?: number; // limit
}
export type QueryResults = Statement[];

export interface FindTermsQuery {
  pos: "subject" | "predicate" | "object" | "graph";
  graph?: string;
  q?: string;
  limit?: number;
}
export type FindTermsResult = string[];
export type QueryResult = Statement;
export type JobStatuses = "created" | "indexing" | "finished" | "canceled" | "error" | "downloading";
export type JobFileInfo = { fileName: string; fileSize: number; sourceFileId: string };
export type JobTypes = "upload" | "download";

export interface Job {
  baseIRI?: string;
  createdAt: string;
  datasetId: string;
  defaultGraphName?: string;
  downloadedBytes: number;
  downloadingProgress: number;
  downloadUrls?: string[];
  error?: ErrorResponse;
  files: JobFileInfo[];
  graphNames?: string[];
  indexedGraphCount: number;
  indexingProgress: number;
  jobId: string;
  jobUrl: string;
  skippedFileCount: number;
  skippedFileNames: string[];
  status: JobStatuses;
  type: JobTypes;
  updatedAt: string;
}

export interface Error {
  code?: number;
  message: string;
}

export interface Topic {
  id: string;
  iri: string;
  label: string;
  description?: string;
  parent?: string;
}

export type TopicUpdates = Array<TopicUpdate>;
export interface TopicUpdate {
  id?: string;
  iri?: string;
  label?: string;
  description?: string;
  parent?: string;
}

export interface SearchResults {
  datasets: Dataset[];
  accounts: Account[];
  moreDatasets: boolean;
  moreAccounts: boolean;
}

export interface ShortUrl {
  shortUrl: string;
  longUrl: string;
}

// Instance limits types.
// we have a config object on the api (LimitConfig), and we have an api path which returns information about the limits (LimitJson).
// to keep them in sync we use a generic interface.
// for the api config object, the whole config tree is optional, and the leaves have a soft and/or hard limit.
// the client-facing json interface has the same structure, but the leaves are the required count and the optional limit (hiding the distinction between soft and hard limit for the client).
// the client-facing json is fully required all through the tree, except for the individual services (since services might be disabled on an instance).
export interface LimitConfigLeaf {
  soft?: number; // admins should be warned about approaching/exceeding the soft limit, but don't technically enforce the limit.
  hard?: number; // we technically enforce this limit.
}
export interface LimitJsonLeaf {
  limit?: number; // the lesser of the soft and hard limit.
  count: number; //
}
interface CountAndStatements<T> {
  // a pattern we repeat a few times, for graphs and services
  count: T;
  statements: T;
}
type PartialIf<T, C> = C extends true ? Partial<T> : T; // Partial if the second type is 'true'
type PartialCountAndStatementsIf<T, C> = PartialIf<CountAndStatements<T>, C>; // a shorthand
export interface InstanceLimits<T, C> {
  users: T;
  organizations: T;
  datasets: T;
  graphs: PartialIf<{ unique: PartialCountAndStatementsIf<T, C>; all: PartialCountAndStatementsIf<T, C> }, C>;
  services: Partial<{ [key in ServiceType]: PartialCountAndStatementsIf<T, C> }> &
    PartialIf<{ all: PartialCountAndStatementsIf<T, C> }, C>;
}
export type InstanceLimitsConfig = Partial<InstanceLimits<LimitConfigLeaf, true>>;

export type InstanceLimitsJson = InstanceLimits<LimitJsonLeaf, false>;

export type StoryElementType = "query" | "paragraph";
export interface StoryElement {
  id: string;
  type: StoryElementType;
  query?: Query;
  queryVersion?: number;
  paragraph?: string;
  caption?: string;
}
export interface Story {
  id: string;
  name: string;
  displayName?: string;
  owner: Account;
  accessLevel: AccessLevel;
  link: string;
  content: StoryElement[];
  createdAt: string;
  updatedAt: string;
  bannerUrl?: string;
}
export interface StoryElementUpdate {
  id?: string;
  type: StoryElementType;
  query?: string;
  queryVersion?: number;
  paragraph?: string;
  caption?: string;
}
export interface StoryUpdate {
  name?: string;
  displayName?: string;
  accessLevel?: AccessLevel;
  content?: StoryElementUpdate[];
}
export interface StoryCreate {
  name: string;
  displayName?: string;
  accessLevel?: AccessLevel;
  content?: StoryElementUpdate[];
}
//Very simple type. Still storing it here, to make sure the API and UI types are consistent
export type RegisterOrLogin = "register" | "login";
