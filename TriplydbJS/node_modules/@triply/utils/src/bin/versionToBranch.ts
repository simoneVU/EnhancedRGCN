#!/usr/bin/env node
import { execSync } from "child_process";
import { printExecSyncError } from "./binUtils";
try {
  const prefix = process.argv[2] || "";

  const newVersion = process.env["npm_package_version"];
  if (!newVersion) {
    console.error(
      "Only run this script via `yarn run` or `yarn exec`. Otherwise, we do not have access to the npm_package_version env variable"
    );
    process.exit(1);
  }

  const currentBranch = execSync("git branch --show-current").toString("utf8").trim();
  let assumeInVersionBranch = false;
  if (currentBranch !== "master" && currentBranch !== "main") {
    assumeInVersionBranch = true;
    console.info(`Assuming we're in a version branch already. We wont commit the package.json in ${currentBranch}`);
  } else {
    commitPkgFiles();
  }
  createNewBranch(newVersion);

  function commitPkgFiles() {
    try {
      execSync(`git commit -n package.json -m "Upped package to ${newVersion}"`, { stdio: "pipe" });
    } catch (e) {
      const errString = e.stdout.toString();
      if (errString.indexOf("nothing to commit") >= 0 || errString.indexOf("nothing added to commit")) return;
      throw e;
    }
  }

  function createNewBranch(newVersion: string) {
    var newBranch = (prefix.length ? prefix + "-" : "") + `v-${newVersion}`;
    console.info("> Creating new branch " + newBranch);
    execSync(`git switch -c ${newBranch}`, { stdio: "pipe" });
    commitPkgFiles();
    console.info("> Pushing branch " + newBranch);
    execSync(`git push origin ${newBranch}`, { stdio: "pipe" });

    console.info(`> Returning to ${currentBranch} branch`);
    execSync(`git switch ${currentBranch}`, { stdio: "pipe" });
    if (!assumeInVersionBranch) {
      console.info(`> Pushing ${currentBranch} branch (skipping the CI for ${currentBranch})`);
      execSync("git push -o ci.skip", { stdio: "pipe" });
    }
  }
} catch (e) {
  printExecSyncError(e);
  process.exit(1);
}
