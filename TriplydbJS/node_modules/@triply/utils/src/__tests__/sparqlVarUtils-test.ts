//external dependencies
import * as chai from "chai";
import { SPARQL_RESULT_DEFAULT_PAGE_SIZE, SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR } from "../Constants";
var expect = chai.expect;
import fs from "fs-extra";
import { Models } from "..";
import {
  getParser,
  getGenerator,
  filterSuggestions,
  parseAndInjectVariablesIntoQuery,
  parseAndInjectVariablesIntoQueryAndGetInfo,
  REGEX_REPLACE_STRING_DATATYPE,
  BadArgumentsError,
} from "../sparqlVarUtils";
const parser = getParser();
const generator = getGenerator();
function normalizeQuery(query: string) {
  return generator.stringify(parser.parse(query)).replace(REGEX_REPLACE_STRING_DATATYPE, "");
}
function testInject(
  query: { original: string; expected: string },
  variableDefinitions: Models.VariableConfig[],
  args: { [key: string]: string }
) {
  /**
   * First try with the sparql parser
   */

  expect(parseAndInjectVariablesIntoQuery(query.original, { variableDefinitions, variableValues: args })).to.equal(
    normalizeQuery(query.expected),
    "failed to inject variables into query using sparql parser"
  );
}

describe("SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR", function () {
  it("should be strictly smaller than one.", function () {
    expect(SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR).to.be.below(1);
  });
  it("should be strictly larger than zero.", function () {
    expect(SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR).to.be.above(0);
  });
});

describe("Sparql var utils", () => {
  /**
   * We've had some issues with SparqlJS, such as throwing errors when it shouldnt, or causing 100% CPU issues
   * To avoid regressing, we've added some tests
   */
  describe("SparqlJS parser tests", function () {
    it("https://issues.triply.cc/issues/4485", async function () {
      const query = await fs.readFile("./src/__tests__/data/invalidQuery_4757.sparql", "utf-8");
      //It's an invalid query, so it should throw. It shouldnt result in a timeout though
      expect(() => parser.parse(query)).to.throw("Parse error");
    });
  });
  describe("Replace query variables", () => {
    it("Sparqlparser output should not contain a datatype", function () {
      //The sparqlparser adds a string datatype to all literals without a datatype.
      //Do not want this, as this complicates queries on virtuoso where a string datatype is treated differently
      //than a literal without a datatype
      expect(
        parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?x ?y "amsterdam"}`, {
          variableDefinitions: [],
          variableValues: {},
        })
      ).not.to.contain("http://www.w3.org/2001/XMLSchema#string");
    });
    it(`Should not throw error on undefined value`, () => {
      parseAndInjectVariablesIntoQuery(
        `
          SELECT * WHERE {
            VALUES ( ?a ?b ) {
              ( "IndividualDifference" UNDEF)
            }
          }`,
        { variableDefinitions: [{ name: "a", defaultValue: "http://bla", termType: "NamedNode" }], variableValues: {} }
      );
    });
    it(`Should not apply sparql parser when no variables are defined`, () => {
      expect(
        parseAndInjectVariablesIntoQuery(`someIllegalQuery`, { variableDefinitions: [], variableValues: {} })
      ).to.equal("someIllegalQuery");
    });
    //see https://github.com/RubenVerborgh/SPARQL.js/issues/99
    it.skip(`Should not throw error on valid property path`, () => {
      parseAndInjectVariablesIntoQuery(
        `
prefix : <https://ex.com/>

select * {
:a :a :a ;
  :a [
    :a/:a :a
  ] .
}
`,

        { variableDefinitions: [{ name: "a", defaultValue: "http://bla", termType: "NamedNode" }], variableValues: {} }
      );
    });
    it(`Check replace`, () => {
      testInject(
        {
          original: `SELECT * WHERE {
            ?s ?p ?o.
            ?s ?p $x.
          }
          `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "amsterdam".
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: true,
          },
        ],
        {
          x: "amsterdam",
        }
      );
    });
    it(`Should use default values`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "amsterdam".
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: true,
            defaultValue: "amsterdam",
          },
        ],
        {}
      );
    });
    it(`Keep original prefix declarations when possible`, () => {
      const result = parseAndInjectVariablesIntoQuery(
        "prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT * WHERE { ?s ?p ?o . ?s ?p $x . }",
        {
          variableDefinitions: [
            {
              name: "x",
              termType: "Literal",
              required: true,
            },
          ],
          variableValues: {
            x: "amsterdam",
          },
        }
      );
      expect(result).to.contain("PREFIX rdf:");
    });
    it("Should throw BadArgumentsError when passing inapplicable arg", () => {
      let e;
      try {
        parseAndInjectVariablesIntoQuery(`ask{?s?p?o}`, { variableDefinitions: [], variableValues: {}, page: 1 });
      } catch (_e) {
        e = _e;
      }
      expect(e).to.be.instanceof(BadArgumentsError);
    });
    it(`Should throw when prefix is not defined`, () => {
      const query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT * WHERE {
          ?s bif:contains ?o.
          ?s ?p ?x.
        }
      `;
      let e: Error | undefined;
      try {
        parseAndInjectVariablesIntoQuery(query, {
          variableDefinitions: [{ name: "s", termType: "NamedNode", defaultValue: "https://bla" }],
          variableValues: {},
        });
      } catch (_e) {
        e = _e;
      }
      expect(e?.message).to.contain("Unknown prefix");
    });
    it(`Don't change variable when not defined`, () => {
      const variables: Models.VariableConfig[] = [
        {
          name: "x",
          termType: "Literal",
          required: false,
        },
      ];
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p ?x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p ?x.
            }
            `,
        },
        variables,
        {}
      );
    });
    it(`Append language tag`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "newX"@en.
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: false,
            language: "en",
          },
        ],
        { x: "newX" }
      );
    });
    it(`Append datatype`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1"^^<http://whatever>.
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: false,
            datatype: "http://whatever",
          },
        ],
        { x: "1" }
      );
    });
    it(`Ignore datatype if it's a string`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: false,
            datatype: "http://www.w3.org/2001/XMLSchema#string",
          },
        ],
        { x: "1" }
      );
    });
    it(`Dont append datatype if not set`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: false,
          },
        ],
        { x: "1" }
      );
    });
    it(`[parser method] Dont append when xsd is added a prefix`, () => {
      testInject(
        {
          original: `
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
        },
        [
          {
            name: "x",
            termType: "Literal",
            required: false,
          },
        ],
        { x: "1" }
      );
    });
    it(`Deal with hashed IRIs as query argument`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
          expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p <https://bla#bla>.
            }
            `,
        },
        [
          {
            name: "x",
            termType: "NamedNode",
            required: false,
          },
        ],
        { x: "https://bla#bla" }
      );
    });
    //This only works when sparql-parsing is used (see the known limitations describe tests)
    it(`Only change variables when sparql-parser is used`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p "$o".
              ?s ?p $o.
            }`,
          expected: `
            SELECT * WHERE {
              ?s ?p "$o".
              ?s ?p "amsterdam".
            }`,
        },
        [
          {
            name: "o",
            termType: "Literal",
            required: true,
          },
        ],
        { o: "amsterdam" }
      );
    });

    it(`Match full queryname`, () => {
      testInject(
        {
          original: `
            SELECT * WHERE {
              ?s ?p ?objects.
              ?s ?p ?obje.
              ?s ?p ?o.
            }`,
          expected: `
            SELECT * WHERE {
              ?s ?p ?objects.
              ?s ?p "amsterdam".
              ?s ?p ?o.
            }`,
        },
        [
          {
            name: "obje",
            termType: "Literal",
            required: true,
          },
        ],
        { obje: "amsterdam" }
      );
    });

    it(`Change both $ and ? variables (Naive)`, () => {
      testInject(
        {
          original: `
            SELECT (count(?s) as ?c) {
              ?s $p ?o.
            }
            `,
          expected: `
            SELECT (count(?s) as ?c) {
              ?s <canada:ontario> "amsterdam".
            }
            `,
        },
        [
          {
            name: "p",
            termType: "NamedNode",
            required: false,
          },
          {
            name: "o",
            termType: "Literal",
            required: false,
          },
        ],
        { p: "canada:ontario", o: "amsterdam" }
      );
    });
  });
  describe("Limit and offset", () => {
    it("Should inject limit and offset into SELECT when given", function () {
      const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?x ?y "amsterdam"}`, {
        variableDefinitions: [],
        variableValues: {},
        page: 2,
        pageSize: 3,
      });
      expect(result).to.contain("LIMIT 3");
      expect(result).to.contain("OFFSET 3");
    });

    it("Should inject limit and offset into DESRIBE when given", function () {
      const result = parseAndInjectVariablesIntoQuery(`DESCRIBE <a:a>`, {
        variableDefinitions: [],
        variableValues: {},
        page: 2,
        pageSize: 3,
      });
      expect(result).to.contain("LIMIT 3");
      expect(result).to.contain("OFFSET 3");
    });
    it("Should inject limit and offset into CONSTRUCT when given", function () {
      const result = parseAndInjectVariablesIntoQuery(`CONSTRUCT {?s?p?o} WHERE {?s?p?o}`, {
        variableDefinitions: [],
        variableValues: {},
        page: 2,
        pageSize: 3,
      });
      expect(result).to.contain("LIMIT 3");
      expect(result).to.contain("OFFSET 3");
    });
    it("Should not inject limit or offset when neither page or pageSize is given", function () {
      const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
        variableDefinitions: [],
        variableValues: {},
      });
      expect(result).not.to.contain("LIMIT");
      expect(result).not.to.contain("OFFSET");
    });
    it("Should handle case where page is given but pageSize is not", function () {
      const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
        variableDefinitions: [],
        variableValues: {},
        page: 2,
      });
      // from 100 to 200: limit 100, offset 100
      expect(result).to.contain(`LIMIT ${SPARQL_RESULT_DEFAULT_PAGE_SIZE}`);
      expect(result).to.contain(`OFFSET ${SPARQL_RESULT_DEFAULT_PAGE_SIZE}`);
    });
    it("Should handle case where pageSize is given but page is not", function () {
      const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
        variableDefinitions: [],
        variableValues: {},
        pageSize: 50,
      });
      expect(result).to.contain("LIMIT 50");
      // when re-serialized, OFFSET 0 gets removed apparently
      expect(result).not.to.contain("OFFSET");
    });
    it("Running a query with blank node twice should return the same bnode identifier", function () {
      const testQuery = `SELECT * WHERE {[]?p?o}`;
      const result = parseAndInjectVariablesIntoQuery(testQuery, {
        variableDefinitions: [],
        variableValues: {},
        pageSize: 50,
      });
      const result2 = parseAndInjectVariablesIntoQuery(testQuery, {
        variableDefinitions: [],
        variableValues: {},
        pageSize: 50,
      });
      expect(result).to.equal(result2);
    });
  });
  describe("Detecting a CONSTRUCT query", function () {
    it("should mark a CONSTRUCT query as being one", function () {
      expect(
        parseAndInjectVariablesIntoQueryAndGetInfo(`CONSTRUCT {?s?p?o} WHERE {?s?p?o}`, {
          variableDefinitions: [],
          variableValues: {},
        }).isConstructQuery
      ).to.equal(true);
    });
    it("should mark a SELECT query as not being a CONSTRUCT query", function () {
      expect(
        parseAndInjectVariablesIntoQueryAndGetInfo(`SELECT * WHERE {?x ?y "amsterdam"}`, {
          variableDefinitions: [],
          variableValues: {},
        }).isConstructQuery
      ).to.equal(false);
    });
    it("should mark a DESRIBE query as not being a CONSTRUCT query", function () {
      expect(
        parseAndInjectVariablesIntoQueryAndGetInfo(`DESCRIBE <a:a>`, {
          variableDefinitions: [],
          variableValues: {},
        }).isConstructQuery
      ).to.equal(false);
    });
  });
  describe("Filter term suggestions", () => {
    it("should filter on datatype", () => {
      const filtered = filterSuggestions(
        {
          name: "whatever",
          termType: "Literal",
        },
        [`"a"@en`, `"b"`]
      );
      expect(filtered).to.have.lengthOf(1);
      expect(filtered[0]).to.equal("b");
    });
  });
});
