import * as Models from "./Models";
import { Parser, Generator, SelectQuery, SparqlQuery } from "sparqljs";
// eslint-disable-next-line lodash/import-scope
import _, { escapeRegExp } from "lodash";
import EachDeepFunc from "deepdash/src/eachDeep";
import * as N3 from "n3";
const eachDeep: typeof EachDeepFunc = require("deepdash/getEachDeep")(_);
import { stringToTerm } from "rdf-string";
import { SPARQL_RESULT_DEFAULT_PAGE_SIZE } from "./Constants";

export function getParser() {
  // The skipUngroupedVariableCheck is a option that was added for https://issues.triply.cc/issues/4771,No typescript update tough so the config is cast as any
  return new Parser({ skipUngroupedVariableCheck: true } as any);
}
export function getGenerator() {
  return new Generator({ allPrefixes: true });
}
const SparqlParser = getParser();
const SparqlGenerator = getGenerator();
const stringDatatype = "http://www.w3.org/2001/XMLSchema#string";
export const REGEX_REPLACE_STRING_DATATYPE = new RegExp(escapeRegExp(`^^<${stringDatatype}>`), "gm");

function stringifySparqlQuery(query: SparqlQuery): string {
  return SparqlGenerator.stringify(query).replace(REGEX_REPLACE_STRING_DATATYPE, "");
}

export class BadArgumentsError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "BadArgumentsError";
  }
}

export interface Options {
  variableDefinitions: Models.VariableConfig[];
  variableValues: { [variableName: string]: string | undefined };
  page?: number;
  pageSize?: number;
}

function parseAndInject(query: string, opts: Options): SparqlQuery {
  const { variableDefinitions, variableValues, page, pageSize } = opts;

  // Need to call this private function in order to reset the blanknode counter,
  // as we always want the counter to start at 0 otherwise it will never cache something with blanknodes
  (SparqlParser as any)._resetBlanks();

  const parsedQuery = SparqlParser.parse(query);

  if (variableDefinitions.length > 0) {
    for (const p in parsedQuery.prefixes) {
      if (parsedQuery.prefixes[p] === "http://www.w3.org/2001/XMLSchema#") {
        //Delete xsd:schema prefix. That way, our string postprocessor (where
        //we remove the string datatype) still works properly
        delete parsedQuery.prefixes[p];
      }
    }
    eachDeep(parsedQuery, (term: N3.Term, key, parentValue) => {
      if (term && term.termType === "Variable") {
        const variableDefinition = variableDefinitions.find((v) => v.name === term.value);
        if (!variableDefinition) return;
        const v = variableValues[term.value] || variableDefinition?.defaultValue;
        if (v) {
          let newVal: N3.Term;
          if (variableDefinition.termType === "NamedNode") {
            newVal = N3.DataFactory.namedNode(v);
          } else {
            //its a literal
            if (variableDefinition.language) {
              newVal = N3.DataFactory.literal(v, variableDefinition.language);
            } else if (variableDefinition.datatype) {
              newVal = N3.DataFactory.literal(v, N3.DataFactory.namedNode(variableDefinition.datatype));
            } else {
              newVal = N3.DataFactory.literal(v);
            }
          }
          parentValue[key] = newVal;
          return false; // No need to go deeper
        }
      }
    });
  }

  if (page !== undefined || pageSize !== undefined) {
    if (parsedQuery.type !== "query") {
      throw new BadArgumentsError("Arguments `page` and `pageSize` are not supported for update queries");
    }
    if (parsedQuery.queryType === "ASK") {
      throw new BadArgumentsError(
        "Arguments `page` and `pageSize` only apply to queries of type `SELECT`, `CONSTRUCT` and `DESCRIBE`."
      );
    }
    const appliedPageSize = pageSize !== undefined ? pageSize : SPARQL_RESULT_DEFAULT_PAGE_SIZE;
    const appliedPage = page !== undefined ? page : 1;
    // typings are wrong. setting limit and offset is also supported for non-SELECT queries.
    (<SelectQuery>parsedQuery).limit = appliedPageSize;
    (<SelectQuery>parsedQuery).offset = (appliedPage - 1) * appliedPageSize;
  }

  return parsedQuery;
}

interface QueryInfo {
  query: string;
  isConstructQuery?: boolean;
  limit?: number;
  offset?: number;
}

export function parseAndInjectVariablesIntoQueryAndGetInfo(query: string, opts: Options): QueryInfo {
  // We always want to try parsing the query, because we want to know whether
  // it is a construct query. (https://issues.triply.cc/issues/4788)
  try {
    const queryWithInjectedVariables = parseAndInject(query, opts);
    return {
      query: stringifySparqlQuery(queryWithInjectedVariables),
      isConstructQuery:
        queryWithInjectedVariables.type === "query" && queryWithInjectedVariables.queryType === "CONSTRUCT",
      limit: (<SelectQuery>queryWithInjectedVariables).limit,
      offset: (<SelectQuery>queryWithInjectedVariables).offset,
    };
  } catch (e) {
    // Allow failing to parse the query if we didn't need to inject anything
    if (opts.page === undefined && opts.pageSize === undefined && opts.variableDefinitions.length === 0)
      return { query };
    throw e;
  }
}

export function parseAndInjectVariablesIntoQuery(query: string, opts: Options) {
  const { variableDefinitions, page, pageSize } = opts;

  // Only parse when necessary
  if (variableDefinitions.length === 0 && page === undefined && pageSize === undefined) {
    return query;
  }
  return stringifySparqlQuery(parseAndInject(query, opts));
}

export function filterSuggestions(forVariableConfiguration: Models.VariableConfig, suggestions: string[]) {
  return suggestions
    .map((suggestedString) => {
      const suggestedTerm = stringToTerm(suggestedString);
      if (suggestedTerm.termType !== forVariableConfiguration.termType) return undefined;
      if (suggestedTerm.termType === "Literal" && forVariableConfiguration.termType === "Literal") {
        if ("datatype" in forVariableConfiguration) {
          // stringToTerm will adds '<' and '>' to datatype
          if (suggestedTerm.datatype.value !== `<${forVariableConfiguration.datatype}>`) return undefined;
        } else if ("language" in forVariableConfiguration) {
          if (suggestedTerm.language !== forVariableConfiguration.language) return undefined;
        } else {
          // stringToTerm will add the string datatype if none is supplied
          if (suggestedTerm?.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" || suggestedTerm.language)
            return undefined;
        }
      }
      return suggestedTerm.value;
    })
    .filter((s) => !!s) as string[];
}
